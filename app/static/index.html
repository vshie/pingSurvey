<!DOCTYPE html>
<html>
<head>
    <title>Simple Ping Survey Extension</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            background-color: #121212;
            color: white;
            font-family: 'Roboto', Arial, sans-serif;
        }
        
        /* Fix for white bar issue */
        html, body {
            height: 100%;
            width: 100%;
        }
        
        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%;
        }
        
        .header {
            background-color: #1E1E1E;
            padding: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 10;
        }
        
        .title {
            text-align: center;
            flex-grow: 1;
            margin: 0;
            font-size: 1.5rem;
        }
        
        .logo {
            width: 40px;
            height: 40px;
            transition: transform 0.5s ease-in-out;
        }
        
        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative; /* For floating buttons */
        }
        
        .map-container {
            flex: 1;
            position: relative;
            min-height: 400px;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        /* Depth legend styles */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: 12px;
            width: 120px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .legend h4 {
            margin: 0 0 5px 0;
            text-align: center;
            font-size: 14px;
        }
        
        .legend-gradient {
            height: 150px;
            width: 30px;
            margin: 5px auto;
            background: linear-gradient(to bottom, 
                rgb(255, 255, 255) 0%,
                rgb(180, 210, 255) 20%,
                rgb(100, 150, 240) 40%,
                rgb(40, 90, 200) 60%,
                rgb(10, 30, 160) 80%,
                rgb(0, 0, 120) 100%);
            border: 1px solid #444;
        }
        
        .legend-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 140px;
            margin-left: 40px;
            margin-top: -145px;
            font-size: 11px;
        }
        
        .legend-labels span {
            font-size: 10px;
            color: #888;
        }
        
        .zoom-level-display {
            margin-bottom: 8px;
            text-align: center;
        }
        
        /* Legend clickable and minimized styles */
        .legend {
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }
        
        .legend:hover {
            background-color: rgba(0, 0, 0, 0.8);
            transform: scale(1.02);
        }
        
        .legend-minimized {
            width: 80px !important;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        
        .legend-minimized-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            color: #ccc;
        }
        
        .legend-minimized-content .v-icon {
            font-size: 16px;
            color: #9C27B0;
        }
        
        .legend-minimized-content span {
            font-size: 10px;
            font-weight: bold;
        }
        
        /* Floating center map button for mobile */
        .map-center-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            background-color: rgba(33, 33, 33, 0.8);
            border-radius: 50%;
            width: 56px;
            height: 56px;
            display: none; /* Hidden by default, shown only on very small screens */
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);
        }
        

        
        /* Caching indicator overlay */
        .caching-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            pointer-events: none; /* Allow clicking through to the map */
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap on small screens */
            gap: 8px;
            padding: 12px;
            background-color: #1E1E1E;
            justify-content: space-between; /* Distribute sections evenly */
        }
        
        .controls-section {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            align-items: center;
        }
        
        .status-panel {
            padding: 16px;
            background-color: #1E1E1E;
            margin-top: 1px;
            overflow-x: auto; /* Allow horizontal scrolling for the table */
        }
        
        .cache-progress-panel {
            padding: 16px;
            background-color: #1E1E1E;
            margin-top: 1px;
            border-top: 2px solid #9C27B0;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .progress-header h4 {
            margin: 0;
            color: #9C27B0;
        }
        
        .progress-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .progress-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .progress-bar-container {
            margin-bottom: 8px;
        }
        
        .progress-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 14px;
        }
        
        .progress-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .progress-label {
            color: #888;
            font-weight: 500;
        }
        
        .progress-value {
            color: white;
            font-weight: 600;
        }
        
        /* Mobile responsiveness for progress panel */
        @media (max-width: 600px) {
            .progress-details {
                grid-template-columns: 1fr;
                gap: 6px;
                font-size: 12px;
            }
            
            .progress-header {
                flex-direction: column;
                gap: 8px;
                align-items: flex-start;
            }
            
            .progress-controls {
                flex-direction: column;
                align-items: flex-start;
                gap: 6px;
            }
            
            .cache-progress-panel {
                padding: 12px;
            }
            
            /* Map source selector on mobile */
            .v-select {
                min-width: 120px !important;
                font-size: 12px;
            }
        }
        
        .confidence-high {
            background-color: #4CAF50;
            color: white;
            text-align: center;
        }

        .confidence-medium {
            background-color: #FFC107;
            color: black;
            text-align: center;
        }

        .confidence-low {
            background-color: #F44336;
            color: white;
            text-align: center;
        }
        
        /* Fix for Vuetify layout issues */
        .v-application--wrap {
            min-height: 100vh;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 600px) {
            .controls {
                justify-content: center;
                flex-direction: column;
                gap: 16px;
            }
            
            .controls-section {
                width: 100%;
                justify-content: center;
            }
            
            .title {
                font-size: 1.2rem;
            }
            
            .logo {
                width: 30px;
                height: 30px;
            }
            
            .map-container {
                min-height: 300px; /* Smaller map on mobile */
            }
            
            .status-panel h4 {
                margin-top: 0;
                margin-bottom: 8px;
                font-size: 16px;
            }
            
            .status-panel {
                padding: 8px;
            }
            
            .v-data-table th, .v-data-table td {
                padding: 0 8px !important;
                font-size: 12px !important;
            }
            
            /* Show floating button on very small screens */
            @media (max-width: 400px) {
                .map-center-button {
                    display: flex;
                }
            }
            
            /* Mobile legend adjustments */
            .legend {
                width: 100px;
                font-size: 10px;
                bottom: 70px; /* Above the center button */
                left: 10px;
                padding: 5px;
            }
            
            .legend-minimized {
                width: 60px !important;
                height: 50px;
                padding: 3px;
            }
            
            .legend h4 {
                font-size: 12px;
            }
            
            .legend-gradient {
                height: 120px;
                width: 20px;
            }
            
            .legend-labels {
                height: 110px;
                margin-top: -115px;
                margin-left: 30px;
                font-size: 9px;
            }
        }
        
        /* Fix for map scrolling issues */
        .leaflet-container {
            touch-action: none;
        }
        
        /* Fix for table on mobile */
        .v-data-table {
            width: 100%;
            overflow-x: auto;
        }
        
        /* Remove all compass rose styles and add polygon drawing styles */
        .polygon-drawing-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background-color: rgba(33, 33, 33, 0.9);
            border-radius: 8px;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
        }
        
        .polygon-drawing-controls h4 {
            margin: 0 0 8px 0;
            color: #9C27B0;
            font-size: 14px;
        }
        
        .polygon-controls-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .polygon-instructions {
            margin-top: 8px;
            font-size: 12px;
            color: #888;
            line-height: 1.4;
        }
        
        .polygon-active {
            background-color: rgba(156, 39, 176, 0.9) !important;
            border-color: rgba(255, 255, 255, 0.6) !important;
        }
        
        /* Polygon vertex styles */
        .polygon-vertex {
            width: 12px;
            height: 12px;
            background-color: #9C27B0;
            border: 2px solid white;
            border-radius: 50%;
            cursor: pointer;
            z-index: 1001;
        }
        
        .polygon-vertex:hover {
            background-color: #E1BEE7;
            transform: scale(1.2);
        }
        
        .polygon-vertex.active {
            background-color: #FF5722;
            border-color: #FF5722;
        }
        
        /* Polygon line styles */
        .polygon-line {
            stroke: #9C27B0;
            stroke-width: 3;
            stroke-dasharray: 5,5;
            fill: none;
            z-index: 1000;
        }
        
        .polygon-fill {
            fill: rgba(156, 39, 176, 0.2);
            stroke: #9C27B0;
            stroke-width: 2;
            z-index: 999;
        }

        /* Enhanced collapsible functionality */
        .progress-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        /* Collapse button styling */
        .collapse-btn {
            background-color: rgba(156, 39, 176, 0.1) !important;
            border: 1px solid rgba(156, 39, 176, 0.3) !important;
        }
        
        .collapse-btn:hover {
            background-color: rgba(156, 39, 176, 0.2) !important;
        }
    </style>
    <link href="/static/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="/static/css/vuetify.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/leaflet.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
</head>
<body>
    <div id="app">
        <v-app>
            <div class="header">
                <img class="logo" :class="{ 'rotate': receivingData }" src="/static/BRlogo.png" alt="Logo">
                <h1 class="title">Simple Ping Survey Extension</h1>
                <img class="logo" :class="{ 'rotate': receivingData }" src="/static/BRlogo.png" alt="Logo">
            </div>
            
            <div class="content">
                <div class="map-container">
                    <div id="map"></div>
                    <!-- Floating center map button for mobile -->
                    <div class="map-center-button" @click="onCenterMapButtonClick">
                        <v-icon color="white">mdi-crosshairs-gps</v-icon>
                    </div>
                    
                    <!-- Polygon Drawing Controls -->
                    <div class="polygon-drawing-controls" v-if="isDrawingPolygon">
                        <h4>Draw Cache Region</h4>
                        <div class="polygon-controls-buttons">
                            <v-btn color="green" dark rounded elevation="2" @click="confirmCacheRegions">
                                <v-icon left>mdi-check</v-icon>
                                Cache This Region
                            </v-btn>
                            <v-btn color="red" dark rounded elevation="2" @click="cancelPolygonDrawing">
                                <v-icon left>mdi-close</v-icon>
                                Cancel
                            </v-btn>
                        </div>
                        <div class="polygon-instructions">
                            Click on the map to add vertices to your cache region. You need at least 3 points to form a polygon. The region inside the polygon will be cached at high zoom levels.
                        </div>
                    </div>
                    
                    <!-- Caching indicator overlay -->
                    <div v-if="cacheProgress.active" class="caching-indicator">
                        <v-chip color="purple" dark>
                            <v-icon left small>mdi-cached</v-icon>
                            Caching in progress...
                        </v-chip>
                    </div>
                    <!-- Depth legend -->
                    <div class="legend" @click="toggleLegend" :class="{ 'legend-minimized': !showLegend }">
                        <div class="zoom-level-display">
                            <v-chip color="info" dark small>
                                <v-icon left small>mdi-magnify</v-icon>
                                Zoom: {{ map ? map.getZoom() : 10 }}
                            </v-chip>
                        </div>
                        <div v-show="showLegend" class="legend-content">
                            <h4>Depth (m)</h4>
                            <div class="legend-gradient"></div>
                            <div class="legend-labels">
                                <span>0</span>
                                <span>20</span>
                                <span>40</span>
                                <span>60</span>
                                <span>80</span>
                                <span>100</span>
                            </div>
                        </div>
                        <div v-show="!showLegend" class="legend-minimized-content">
                            <v-icon>mdi-chevron-right</v-icon>
                            <span>Depth</span>
                        </div>
                    </div>
                </div>
                
                <div class="controls">
                    <!-- Left side - Start/Stop and Download -->
                    <div class="controls-section">
                        <v-btn :color="run ? 'error' : 'success'" :disabled="isLoading" 
                               dark rounded elevation="2" @click="toggleRun">
                            <v-icon left>{{ run ? 'mdi-stop' : 'mdi-play' }}</v-icon>
                            {{ run ? 'Stop' : 'Start' }}
                        </v-btn>
                        <v-btn color="primary" dark rounded elevation="2" @click="download">
                            <v-icon left>mdi-download</v-icon>
                            Download
                        </v-btn>
                    </div>
                    
                    <!-- Center section - Map Controls -->
                    <div class="controls-section">
                        <v-btn color="info" dark rounded elevation="2" @click="onCenterMapButtonClick">
                            <v-icon left>mdi-crosshairs-gps</v-icon>
                            Center
                        </v-btn>
                        <v-btn color="warning" dark rounded elevation="2" @click="clearHeatmap">
                            <v-icon left>mdi-delete</v-icon>
                            Clear
                        </v-btn>
                        <v-select
                            v-model="selectedMapSource"
                            :items="Object.keys(mapSources)"
                            :item-text="key => mapSources[key].name"
                            :item-value="key => key"
                            label="Map Source"
                            dark
                            dense
                            outlined
                            hide-details
                            style="min-width: 150px;"
                            @change="changeMapSource"
                        ></v-select>
                        <v-btn color="purple" dark rounded elevation="2" @click="togglePolygonDrawing" :loading="cacheLoading" :disabled="cacheProgress.active">
                            <v-icon left>mdi-cached</v-icon>
                            {{ isDrawingPolygon ? 'Cancel Drawing' : 'Cache Region' }}
                        </v-btn>
                        <v-btn color="green" dark rounded elevation="2" @click="getRecentCachedArea" v-if="cacheStats.cachedTiles > 0">
                            <v-icon left>mdi-map-marker</v-icon>
                            Recent Area
                        </v-btn>
                        <v-btn color="blue" dark rounded elevation="2" @click="getCacheStats">
                            <v-icon left>mdi-refresh</v-icon>
                            Refresh
                        </v-btn>
                        <v-btn color="red" dark rounded elevation="2" @click="confirmClearCache">
                            <v-icon left>mdi-delete-sweep</v-icon>
                            Clear Cache
                        </v-btn>
                    </div>
                </div>
                
                <!-- Status Console - Directly beneath the map -->
                <div class="status-panel">
                    <h4>Status Console</h4>
                    <v-data-table
                        :headers="tableHeaders"
                        :items="tableItems"
                        :hide-default-footer="true"
                        dense
                        class="elevation-1"
                    >
                    <template v-slot:item.confidence="{ item }">
                        <td :class="getConfidenceClass(item.confidence)">
                            {{ item.confidence }}
                        </td>
                    </template>
                    </v-data-table>
                </div>
                
                <!-- Cache Progress Bar -->
                <div v-if="cacheProgress.active" class="cache-progress-panel">
                    <div class="progress-header">
                        <h4>Cache Progress</h4>
                        <div class="progress-controls">
                            <v-chip small color="info" class="mr-2">
                                <v-icon left small>mdi-information</v-icon>
                                Map can be moved freely
                            </v-chip>
                            <v-chip small color="success" class="mr-2">
                                <v-icon left small>mdi-content-save</v-icon>
                                Persistent storage
                            </v-chip>
                            <v-btn small color="error" @click="cancelCaching" :disabled="!cacheProgress.active">
                                <v-icon left>mdi-close</v-icon>
                                Cancel
                            </v-btn>
                            <v-btn small icon @click="cacheProgressCollapsed = !cacheProgressCollapsed" class="ml-2 collapse-btn">
                                <v-icon>{{ cacheProgressCollapsed ? 'mdi-chevron-down' : 'mdi-chevron-up' }}</v-icon>
                            </v-btn>
                        </div>
                    </div>
                    <div v-show="!cacheProgressCollapsed" class="progress-content">
                        <div class="progress-bar-container">
                            <v-progress-linear
                                :value="cacheProgress.percentage"
                                color="purple"
                                height="25"
                                striped
                                stream
                            >
                                <template v-slot:default="{ value }">
                                    <strong>{{ Math.ceil(value) }}%</strong>
                                </template>
                            </v-progress-linear>
                        </div>
                        <div class="progress-details">
                            <div class="progress-row">
                                <span class="progress-label">Zoom Level:</span>
                                <span class="progress-value">{{ cacheProgress.currentZoom }} → {{ cacheProgress.maxZoom }}</span>
                            </div>
                            <div class="progress-row">
                                <span class="progress-label">Tiles Processed:</span>
                                <span class="progress-value">{{ cacheProgress.tilesProcessed }} / {{ cacheProgress.totalTiles }}</span>
                            </div>
                            <div class="progress-row">
                                <span class="progress-label">New Tiles Cached:</span>
                                <span class="progress-value">{{ cacheProgress.newTilesCached }}</span>
                            </div>
                            <div class="progress-row">
                                <span class="progress-label">Already Cached:</span>
                                <span class="progress-value">{{ cacheProgress.alreadyCached }}</span>
                            </div>
                            <div class="progress-row">
                                <span class="progress-label">Status:</span>
                                <span class="progress-value">{{ cacheProgress.status }}</span>
                            </div>
                            <div class="progress-row">
                                <span class="progress-label">Storage:</span>
                                <span class="progress-value">{{ cacheStats.cacheLocation }}</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Simulation and Log Controls Panel -->

            </div>
        </v-app>
        

    </div>

    <script src="/static/js/vue.js"></script>
    <script src="/static/js/vuetify.js"></script>
    <script src="/static/js/axios.min.js"></script>
    <script src="/static/js/leaflet.js"></script>

    <script src="/static/js/leaflet-heat.js"></script>
    <script>

        
        new Vue({
            el: '#app',
            vuetify: new Vuetify({
                theme: {
                    dark: true,
                },
            }),
            data() {
                return {
                    status: "",
                    firstCoordinateReceived: false,
                    icon: 'mdi-play',
                    run: false,
                    map: null,
                    circleMarkers: [],
                    isLoading: false,
                    receivingData: false,
                    scaleAdded: false,
                    showLegend: true,

                    cacheStats: {
                        cachedTiles: 0,
                        cacheSizeMB: 0,
                        cacheLimitMB: 5120,
                        cacheLocation: '/app/logs/offline_maps'
                    },
                    cacheLoading: false,
                    cacheProgress: {
                        active: false,
                        percentage: 0,
                        currentZoom: 0,
                        maxZoom: 0,
                        tilesProcessed: 0,
                        totalTiles: 0,
                        newTilesCached: 0,
                        alreadyCached: 0,
                        status: ''
                    },
                    cacheStatsRefreshTimeout: null,
                    cacheStatsInterval: null,
                    recentCachedArea: {
                        has_cached_tiles: false,
                        center_lat: 9.2,
                        center_lon: -133,
                        zoom: 10
                    },
                    mapSources: {
                        google: {
                            name: 'Google Maps',
                            url: 'https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',
                            attribution: '&copy; <a href="https://www.google.com/maps">Google Maps</a>'
                        },
                        arcgis: {
                            name: 'ArcGIS World Imagery',
                            url: 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                            attribution: '&copy; <a href="https://www.esri.com/">Esri</a> — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community'
                        }
                    },
                    selectedMapSource: 'google',

                    customIcon: L.icon({
                        iconUrl: '/static/BB.png',
                        iconSize: [32, 45],
                        iconAnchor: [12, 26]
                    }),
                    tableHeaders: [
                        { text: 'Latitude', value: 'latitude', align: 'center' },
                        { text: 'Longitude', value: 'longitude', align: 'center' },
                        { text: 'Depth (m)', value: 'depth', align: 'center' },
                        { text: 'Beam Coverage Diameter (m)', value: 'beamCoverageDiameter', align: 'center' },
                        { text: 'Confidence (%)', value: 'confidence', align: 'center' },
                        { text: 'Yaw (deg)', value: 'yaw', align: 'center' },
                        { text: 'Roll (deg)', value: 'roll', align: 'center' },
                        { text: 'Pitch (deg)', value: 'pitch', align: 'center' },
                        { text: 'Altitude (m)', value: 'altitude', align: 'center' }
                    ],
                    tableItems: [],
                    randomNames: [
                        'Ocean_Opulence_Survey', 'Tidal_Tidbits_Collection', 'Seabed_Delights_Map',
                        'Benthic_Base_Basis', 'Whimsy_Wavy_Data', 'Infinite_Seas_Quantified',
                        'Tide_Tomfoolery_Tracking', 'Marine_Mirth_Measurements', 'Aqua_Antics_Archive'
                    ],

                    polygonVertices: [],
                    polygonActive: false,
                    polygonLayers: [],
                    isDrawingPolygon: false,
                    cacheProgressCollapsed: false,

                }
            },
            methods: {
                async toggleRun() {
                    this.icon = this.icon === 'mdi-play' ? 'mdi-stop' : 'mdi-play';
                    this.run = !this.run;
                    if (this.run) {
                        await this.start();
                    } else {
                        await this.stop();
                    }
                },
                async start() {
                    try {
                        const response = await fetch('/start');
                        if (!response.ok) {
                            throw new Error(`HTTP error! Status: ${response.status}`);
                        }
                        this.status = 'Data logging started.';
                        this.receivingData = true;
                        this.resetMap(9.2, -133, 10);
                        this.intervalId = setInterval(this.fetchData, 1000);
                    } catch (error) {
                        console.error('Error fetching data:', error);
                        this.status = 'Error: ' + error.message;
                    }
                },
                async stop() {
                    try {
                        const response = await fetch('/stop');
                        if (!response.ok) {
                            throw new Error(`HTTP error! Status: ${response.status}`);
                        }
                        this.status = 'Data logging stopped.';
                        this.receivingData = false; // Ensure animation stops
                        clearInterval(this.intervalId);
                    } catch (error) {
                        console.error('Error fetching data:', error);
                        this.status = 'Error: ' + error.message;
                    }
                },
                async download() {
                    try {
                        const response = await fetch('/download');
                        if (!response.ok) {
                            throw new Error(`HTTP error! Status: ${response.status}`);
                        }
                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const randomName = this.randomNames[Math.floor(Math.random() * this.randomNames.length)];
                        const timestamp = new Date().toLocaleString('en-US', { 
                            month: '2-digit', day: '2-digit', year: 'numeric', 
                            hour: '2-digit', minute: '2-digit', second: '2-digit' 
                        }).replace(',', '');
                        const fileName = `${randomName}_finished_at_${timestamp}.csv`;
                        const link = document.createElement('a');
                        link.href = url;
                        link.setAttribute('download', fileName);
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        this.status = `Data file downloaded: ${fileName}`;
                    } catch (error) {
                        console.error('Error fetching data:', error);
                        this.status = 'Error: ' + error.message;
                    }
                },
                async fetchData() {
                    try {
                        const response = await axios.get('/data');
                        this.status = JSON.stringify(response.data);
                        
                        // Make sure we have valid data to work with (should always be 11 points)
                        if (!response.data || !Array.isArray(response.data) || response.data.length < 11) {
                            console.error('Invalid data format received:', response.data);
                            return;
                        }
                        
                        let angleRadians = (12.5 * Math.PI) / 180;
                        let beamCoverageDiameter = ((2 * Math.atan(angleRadians) * response.data[3])/100).toFixed(2);
                        
                        // Ensure we handle both old and new data formats
                        const data = response.data;
                        const hasNewFormat = data.length >= 11;
                        
                        this.tableItems = [{
                            latitude: hasNewFormat ? data[8] : data[6],
                            longitude: hasNewFormat ? data[9] : data[7],
                            depth: data[3]/ 100,
                            beamCoverageDiameter: beamCoverageDiameter,
                            confidence: data[4],
                            yaw: data[5],
                            roll: hasNewFormat ? data[6] : 0,
                            pitch: hasNewFormat ? data[7] : 0,
                            altitude: hasNewFormat ? data[10] : 0
                        }];

                        // Use the correct lat/lon based on format
                        const lat = hasNewFormat ? data[8] : data[6];
                        const lon = hasNewFormat ? data[9] : data[7];
                        
                        this.updateMarker(lat, lon, data[3], data[4], data[5]);
                        
                        // Always center on GPS data if we haven't received coordinates yet
                        if (!this.firstCoordinateReceived) {
                            this.firstCoordinateReceived = true;
                            this.map.setView([lat, lon], 18);
                        }
                        
                        // Toggle animation only if still logging
                        if (this.run) {
                            this.receivingData = !this.receivingData;
                        }
                    } catch (error) {
                        console.error('Error fetching data:', error);
                        this.status = 'Error: ' + error.message;
                    }
                },
                updateMarker(lat, lon, depth, confidence, yaw) {
                    if (this.marker) {
                        this.map.removeLayer(this.marker);
                    }
                    
                    this.marker = L.marker([lat, lon], {
                        icon: this.customIcon
                    });
                    this.marker.addTo(this.map);
                    
                    // Only show depth circles if we have high confidence ping data (confidence >= 90)
                    if (confidence >= 90) {   
                        const radiusInMeters = (depth/100) * Math.tan(12.5 * Math.PI / 180);
                        const radius = radiusInMeters * this.map.getZoomScale(this.map.getZoom());
                        const fillColor = this.getColor(depth);
                        
                        // Create a more visible circle with stronger border
                        const circleMarker = L.circle([lat, lon], {
                            color: 'black',       // Black outline for contrast against all colors
                            fillColor: fillColor,
                            fillOpacity: 0.7,     // Higher opacity for better visibility
                            weight: 1,           // Thin but visible border
                            radius: radius
                        });
                        circleMarker.addTo(this.map);
                        this.circleMarkers.push(circleMarker);
                    }
                },
                clearHeatmap() {
                    this.circleMarkers.forEach(circleMarker => {
                        circleMarker.remove();
                    });
                    this.circleMarkers = [];
                },
                onCenterMapButtonClick() {
                    this.firstCoordinateReceived = false;
                    
                    // If we have GPS data already, center on that
                    if (this.tableItems.length > 0) {
                        const item = this.tableItems[0];
                        this.resetMap(item.latitude, item.longitude, 18);
                    } else if (this.recentCachedArea.has_cached_tiles) {
                        // If we have cached tiles, center on the recent area
                        this.resetMap(this.recentCachedArea.center_lat, this.recentCachedArea.center_lon, this.recentCachedArea.zoom);
                    } else {
                        // Otherwise reset to default view
                        this.resetMap(9.2, -133, 10);
                    }
                },
                getColor(depth) {
                    const colorStops = [
                        {depth: 0, color: [255, 255, 255]},    // Pure white for shallow
                        {depth: 1000, color: [220, 230, 255]}, 
                        {depth: 2000, color: [180, 210, 255]},
                        {depth: 3000, color: [140, 180, 250]},
                        {depth: 4000, color: [100, 150, 240]},
                        {depth: 5000, color: [70, 120, 220]},
                        {depth: 6000, color: [40, 90, 200]},
                        {depth: 7000, color: [20, 60, 180]},
                        {depth: 8000, color: [10, 30, 160]},
                        {depth: 9000, color: [5, 15, 140]},
                        {depth: 10000, color: [0, 0, 120]}      // Dark blue for deep
                    ];
                    
                    // Add higher contrast to circles
                    const opacity = 0.7; // Higher opacity for better visibility
                    const strokeWeight = 1; // Add stroke to improve contrast
                    
                    let color1, color2;
                    for (let i = 0; i < colorStops.length - 1; i++) {
                        if (depth >= colorStops[i].depth && depth <= colorStops[i + 1].depth) {
                            color1 = colorStops[i];
                            color2 = colorStops[i + 1];
                            break;
                        }
                    }
                    
                    if (!color1) {
                        return depth <= 0 ? `rgb(${colorStops[0].color})` : `rgb(${colorStops[colorStops.length - 1].color})`;
                    }
                    
                    const t = (depth - color1.depth) / (color2.depth - color1.depth);
                    const color = color1.color.map((start, i) => {
                        return Math.round(start + (color2.color[i] - start) * t);
                    });
                    
                    return `rgb(${color})`;
                },
                getConfidenceClass(confidence) {
                    if (confidence > 95) return 'confidence-high';
                    if (confidence > 80) return 'confidence-medium';
                    return 'confidence-low';
                },

                async checkLoggingStatus() {
                    try {
                        const response = await axios.get('/status');
                        if (response.data.logging_active) {
                            this.run = true;
                            this.icon = 'mdi-stop';
                            this.resetMap(9.2, -133, 10);
                            this.intervalId = setInterval(this.fetchData, 1000);
                        } else {
                            this.run = false;
                            this.icon = 'mdi-play';
                        }
                        

                    } catch (error) {
                        console.error('Error fetching status:', error);
                        this.run = false;
                        this.icon = 'mdi-play';
                    }
                },
                resetMap(lat, lon, zoom) {
                    // Remove existing layers to prevent duplicate controls
                    if (this.map) {
                        this.map.eachLayer((layer) => {
                            if (layer instanceof L.TileLayer) {
                                this.map.removeLayer(layer);
                            }
                        });
                    
                        // Clear any existing controls including scale
                        const controls = this.map._controlCorners;
                        if (controls && controls.bottomleft) {
                            while (controls.bottomleft.firstChild) {
                                controls.bottomleft.removeChild(controls.bottomleft.firstChild);
                            }
                        }
                        
                        // Reset the map view
                        this.map.setView([lat, lon], zoom);
                        
                        // Fix mobile handling if needed
                        if (L.Browser.mobile) {
                            // Ensure touch handling is properly set
                            this.map.tap.enable();
                            // Disable dragging and re-enable after a slight delay
                            this.map.dragging.disable();
                            setTimeout(() => {
                                this.map.dragging.enable();
                            }, 500);
                        }
                        
                        // Add base layer with offline caching
                        this.createOfflineTileLayer().addTo(this.map);
                        
                        // Add fresh scale control
                        L.control.scale({imperial: false}).addTo(this.map);
                        this.scaleAdded = true;
                    }
                },
                toggleLegend() {
                    this.showLegend = !this.showLegend;
                },
                async getCacheStats() {
                    this.cacheLoading = true;
                    try {
                        const response = await fetch('/cache_stats');
                        const stats = await response.json();
                        console.log('Cache stats received:', stats);
                        // Convert backend snake_case to frontend camelCase
                        this.cacheStats = {
                            cachedTiles: stats.cached_tiles || 0,
                            cacheSizeMB: stats.cache_size_mb || 0,
                            cacheLimitMB: stats.cache_limit_mb || 5120,
                            cacheLocation: stats.cache_location || '/app/logs/offline_maps'
                        };
                        console.log('Cache stats converted:', this.cacheStats);
                    } catch (error) {
                        console.error('Error fetching cache stats:', error);
                        this.cacheStats = { cachedTiles: 0, cacheSizeMB: 0, cacheLimitMB: 5120 };
                    } finally {
                        this.cacheLoading = false;
                    }
                },
                async cacheVisibleTiles() {
                    if (!this.map) {
                        alert('Map not initialized');
                        return;
                    }
                    
                    // Initialize progress tracking
                    this.cacheProgress = {
                        active: true,
                        percentage: 0,
                        currentZoom: this.map.getZoom(),
                        maxZoom: 19,
                        tilesProcessed: 0,
                        totalTiles: 0,
                        newTilesCached: 0,
                        alreadyCached: 0,
                        status: 'Calculating tiles...'
                    };
                    
                    this.cacheLoading = true;
                    
                    try {
                        // Capture the bounds and zoom at the start of caching - these won't change during the process
                        const initialBounds = this.map.getBounds();
                        const initialZoom = this.map.getZoom();
                        const maxZoom = 19; // Maximum zoom level
                        
                        console.log(`Caching tiles from zoom ${initialZoom} to ${maxZoom} for initial bounds:`, initialBounds);
                        
                        let totalTiles = 0;
                        let newTilesCached = 0;
                        let alreadyCached = 0;
                        
                        // Calculate total tiles first using initial bounds
                        this.cacheProgress.status = 'Calculating total tiles...';
                        for (let z = initialZoom; z <= maxZoom; z++) {
                            const tiles = this.getTilesForBounds(initialBounds, z);
                            totalTiles += tiles.length;
                        }
                        
                        this.cacheProgress.totalTiles = totalTiles;
                        this.cacheProgress.status = `Starting cache process for ${totalTiles} tiles...`;
                        
                        // Cache tiles for each zoom level from initial to max
                        for (let z = initialZoom; z <= maxZoom; z++) {
                            this.cacheProgress.currentZoom = z;
                            this.cacheProgress.status = `Processing zoom level ${z}...`;
                            
                            const tiles = this.getTilesForBounds(initialBounds, z);
                            console.log(`Zoom ${z}: ${tiles.length} tiles to check/cache`);
                            
                            // Skip if no tiles to process
                            if (tiles.length === 0) {
                                console.log(`No tiles for zoom ${z}, skipping`);
                                continue;
                            }
                            
                                                            // Process tiles in batches to avoid overwhelming the server
                                const batchSize = 5;
                                for (let i = 0; i < tiles.length; i += batchSize) {
                                    // Check if caching was cancelled
                                    if (!this.cacheProgress.active) {
                                        console.log('Caching cancelled by user');
                                        return;
                                    }
                                    
                                    const batch = tiles.slice(i, i + batchSize);
                                    
                                    // Check which tiles are already cached
                                    const checkPromises = batch.map(tile => this.checkTileCached(tile.z, tile.x, tile.y));
                                    const checkResults = await Promise.allSettled(checkPromises);
                                    
                                    // Filter out already cached tiles
                                    const tilesToCache = [];
                                    for (let j = 0; j < batch.length; j++) {
                                        const result = checkResults[j];
                                        if (result.status === 'fulfilled' && !result.value) {
                                            tilesToCache.push(batch[j]);
                                        } else if (result.status === 'fulfilled' && result.value) {
                                            alreadyCached++;
                                        }
                                    }
                                    
                                    console.log(`Batch ${Math.floor(i/batchSize) + 1}: ${tilesToCache.length} new tiles to cache, ${batch.length - tilesToCache.length} already cached`);
                                    
                                    // Cache only new tiles
                                    if (tilesToCache.length > 0) {
                                        const cachePromises = tilesToCache.map(tile => this.cacheTile(tile.z, tile.x, tile.y));
                                        const cacheResults = await Promise.allSettled(cachePromises);
                                        
                                        // Count successful caches
                                        newTilesCached += cacheResults.filter(r => r.status === 'fulfilled' && r.value).length;
                                    }
                                    
                                    // Update progress
                                    this.cacheProgress.tilesProcessed += batch.length;
                                    this.cacheProgress.newTilesCached = newTilesCached;
                                    this.cacheProgress.alreadyCached = alreadyCached;
                                    this.cacheProgress.percentage = (this.cacheProgress.tilesProcessed / this.cacheProgress.totalTiles) * 100;
                                    this.cacheProgress.status = `Processing batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(tiles.length/batchSize)} (${this.cacheProgress.tilesProcessed}/${this.cacheProgress.totalTiles} tiles)`;
                                    
                                    // Update cache stats every few batches
                                    if (i % (batchSize * 3) === 0) {
                                        await this.getCacheStats();
                                    }
                                    
                                    // Small delay to avoid overwhelming the server
                                    await new Promise(resolve => setTimeout(resolve, 200));
                                }
                        }
                        
                        console.log(`Caching complete: ${newTilesCached} new tiles cached, ${alreadyCached} already cached, ${totalTiles} total processed`);
                        await this.getCacheStats();
                        
                        // Update final progress
                        this.cacheProgress.percentage = 100;
                        this.cacheProgress.status = 'Caching complete!';
                        
                        // Show completion message
                        setTimeout(() => {
                            alert(`Caching complete!\n\n${newTilesCached} new tiles cached\n${alreadyCached} tiles already cached\nTotal tiles processed: ${totalTiles}\nZoom levels: ${initialZoom} to ${maxZoom}`);
                            
                            // Hide progress panel after a delay
                            setTimeout(() => {
                                this.cacheProgress.active = false;
                            }, 3000);
                        }, 500);
                        
                    } catch (error) {
                        console.error('Error caching visible tiles:', error);
                        this.cacheProgress.status = 'Error: ' + error.message;
                        alert('Error caching tiles: ' + error.message);
                    } finally {
                        this.cacheLoading = false;
                        if (this.cacheProgress.active) {
                            // Keep progress panel visible for a moment to show error
                            setTimeout(() => {
                                this.cacheProgress.active = false;
                            }, 5000);
                        }
                    }
                },
                getTilesForBounds(bounds, zoom) {
                    const tiles = [];
                    const north = bounds.getNorth();
                    const south = bounds.getSouth();
                    const east = bounds.getEast();
                    const west = bounds.getWest();
                    
                    console.log(`Bounds for zoom ${zoom}:`, { north, south, east, west });
                    
                    // Convert bounds to tile coordinates
                    const northWestTile = this.latLngToTile(north, west, zoom);
                    const southEastTile = this.latLngToTile(south, east, zoom);
                    
                    // Ensure we get the correct min/max tile coordinates
                    const minX = Math.floor(Math.min(northWestTile.x, southEastTile.x));
                    const maxX = Math.ceil(Math.max(northWestTile.x, southEastTile.x));
                    const minY = Math.floor(Math.min(northWestTile.y, southEastTile.y));
                    const maxY = Math.ceil(Math.max(northWestTile.y, southEastTile.y));
                    
                    console.log(`Tile bounds for zoom ${zoom}:`, { minX, maxX, minY, maxY });
                    
                    // Generate all tile coordinates in the bounds
                    for (let y = minY; y <= maxY; y++) {
                        for (let x = minX; x <= maxX; x++) {
                            tiles.push({ z: zoom, x: x, y: y });
                        }
                    }
                    
                    console.log(`Generated ${tiles.length} tiles for zoom ${zoom}`);
                    return tiles;
                },
                latLngToTile(lat, lng, zoom) {
                    const n = Math.pow(2, zoom);
                    const x = ((lng + 180) / 360) * n;
                    const y = (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n;
                    return { x: x, y: y };
                },
                async checkTileCached(z, x, y) {
                    try {
                        const response = await fetch(`/tile_cached/${z}/${x}/${y}`);
                        const data = await response.json();
                        return data.cached;
                    } catch (error) {
                        console.error(`Error checking if tile ${z}/${x}/${y} is cached:`, error);
                        return false;
                    }
                },
                async cacheTile(z, x, y) {
                    try {
                        console.log(`Attempting to cache tile: ${z}/${x}/${y}`);
                        const response = await fetch(`/tiles/${z}/${x}/${y}.png?source=${this.selectedMapSource}`);
                        const success = response.ok;
                        console.log(`Tile ${z}/${x}/${y} cache result: ${success ? 'SUCCESS' : 'FAILED'} (${response.status})`);
                        return success;
                    } catch (error) {
                        console.error(`Error caching tile ${z}/${x}/${y}:`, error);
                        return false;
                    }
                },
                async confirmClearCache() {
                    // Get current cache stats first
                    await this.getCacheStats();
                    
                    if (this.cacheStats.cachedTiles === 0) {
                        alert('No tiles are currently cached.');
                        return;
                    }
                    
                    const message = `Are you sure you want to clear the cache?\n\nThis will remove ${this.cacheStats.cachedTiles} cached tiles.\n\nThis action cannot be undone.`;
                    
                    if (confirm(message)) {
                        await this.clearCache();
                    }
                },
                async clearCache() {
                    try {
                        const response = await fetch('/clear_cache');
                        const result = await response.json();
                        alert(result.message);
                        await this.getCacheStats();
                    } catch (error) {
                        console.error('Error clearing cache:', error);
                        alert('Error clearing cache');
                    }
                },
                createOfflineTileLayer() {
                    // Create a custom tile layer that uses our offline-capable backend
                    const sourceConfig = this.mapSources[this.selectedMapSource];
                    const tileLayer = L.tileLayer(`/tiles/{z}/{x}/{y}.png?source=${this.selectedMapSource}`, {
                        maxZoom: 19,
                        attribution: sourceConfig.attribution + ' (Offline Cached)',
                        errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7' // Transparent tile for missing tiles
                    });
                    
                    // Refresh cache stats when tiles are loaded
                    tileLayer.on('tileload', () => {
                        // Debounce cache stats refresh to avoid too many requests
                        if (this.cacheStatsRefreshTimeout) {
                            clearTimeout(this.cacheStatsRefreshTimeout);
                        }
                        this.cacheStatsRefreshTimeout = setTimeout(() => {
                            this.getCacheStats();
                        }, 2000); // Refresh after 2 seconds of inactivity
                    });
                    
                    return tileLayer;
                },
                startCacheStatsRefresh() {
                    // Refresh cache stats every 30 seconds
                    this.cacheStatsInterval = setInterval(() => {
                        this.getCacheStats();
                    }, 30000);
                },
                stopCacheStatsRefresh() {
                    if (this.cacheStatsInterval) {
                        clearInterval(this.cacheStatsInterval);
                        this.cacheStatsInterval = null;
                    }
                },
                async getRecentCachedArea() {
                    try {
                        const response = await fetch('/recent_cached_area');
                        const data = await response.json();
                        this.recentCachedArea = data;
                        
                        // If we have cached tiles, center the map on the most recent area
                        if (data.has_cached_tiles && this.map) {
                            this.map.setView([data.center_lat, data.center_lon], data.zoom);
                            console.log(`Centered map on recent cached area: ${data.center_lat}, ${data.center_lon} at zoom ${data.zoom}`);
                        }
                    } catch (error) {
                        console.error('Error fetching recent cached area:', error);
                    }
                },
                cancelCaching() {
                    this.cacheProgress.active = false;
                    this.cacheProgress.status = 'Cancelled by user';
                    this.cacheLoading = false;
                    console.log('Caching cancelled by user');
                },
                changeMapSource() {
                    console.log(`Changing map source to: ${this.selectedMapSource}`);
                    if (this.map) {
                        // Remove existing tile layer
                        this.map.eachLayer((layer) => {
                            if (layer instanceof L.TileLayer) {
                                this.map.removeLayer(layer);
                            }
                        });
                        
                        // Add new tile layer with selected source
                        this.createOfflineTileLayer().addTo(this.map);
                        
                        // Update attribution
                        const sourceConfig = this.mapSources[this.selectedMapSource];
                        console.log(`Map source changed to: ${sourceConfig.name}`);
                    }
                },
                async loadMapSources() {
                    try {
                        const response = await fetch('/map_sources');
                        const sources = await response.json();
                        if (sources && Object.keys(sources).length > 0) {
                            this.mapSources = sources;
                            console.log('Loaded map sources from backend:', sources);
                        }
                    } catch (error) {
                        console.error('Error loading map sources:', error);
                        // Keep using the default sources defined in data
                    }
                },

                // Toggle polygon drawing mode
                togglePolygonDrawing() {
                    if (this.isDrawingPolygon) {
                        // If already drawing, cancel it
                        this.cancelPolygonDrawing();
                    } else {
                        // Start drawing mode
                        this.startPolygonDrawing();
                    }
                },
                // Polygon drawing methods
                startPolygonDrawing() {
                    this.isDrawingPolygon = true;
                    this.polygonVertices = [];
                    this.clearPolygonLayers();
                    
                    // Add click handler to map
                    this.map.on('click', this.addPolygonVertex);
                    
                    this.status = 'Click on the map to add vertices to your cache region polygon.';
                },
                
                addPolygonVertex(event) {
                    if (!this.isDrawingPolygon) return;
                    
                    const latlng = event.latlng;
                    this.polygonVertices.push([latlng.lat, latlng.lng]);
                    
                    // Add vertex marker
                    const vertex = L.circleMarker(latlng, {
                        radius: 6,
                        fillColor: '#9C27B0',
                        color: 'white',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8
                    }).addTo(this.map);
                    
                    this.polygonLayers.push(vertex);
                    
                    // Draw polygon if we have enough vertices
                    if (this.polygonVertices.length >= 3) {
                        this.drawPolygon();
                    }
                    
                    this.status = `Added vertex ${this.polygonVertices.length}. Click to add more or use "Confirm Regions" to save.`;
                },
                
                drawPolygon() {
                    // Remove existing polygon
                    this.clearPolygonLayers();
                    
                    // Add vertex markers
                    this.polygonVertices.forEach(vertex => {
                        const marker = L.circleMarker(vertex, {
                            radius: 6,
                            fillColor: '#9C27B0',
                            color: 'white',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.8
                        }).addTo(this.map);
                        this.polygonLayers.push(marker);
                    });
                    
                    // Draw polygon
                    const polygon = L.polygon(this.polygonVertices, {
                        color: '#9C27B0',
                        weight: 3,
                        fillOpacity: 0.2,
                        fillColor: '#9C27B0'
                    }).addTo(this.map);
                    
                    this.polygonLayers.push(polygon);
                },
                
                clearPolygonLayers() {
                    this.polygonLayers.forEach(layer => {
                        if (this.map.hasLayer(layer)) {
                            this.map.removeLayer(layer);
                        }
                    });
                    this.polygonLayers = [];
                },
                
                confirmCacheRegions() {
                    if (this.polygonVertices.length < 3) {
                        alert('Please draw a polygon with at least 3 vertices before caching.');
                        return;
                    }
                    
                    this.isDrawingPolygon = false;
                    this.map.off('click', this.addPolygonVertex);
                    
                    // Cache the region within the polygon
                    this.cachePolygonRegion();
                },
                
                cancelPolygonDrawing() {
                    this.isDrawingPolygon = false;
                    this.polygonVertices = [];
                    this.clearPolygonLayers();
                    this.map.off('click', this.addPolygonVertex);
                    this.status = 'Polygon drawing cancelled.';
                },
                
                async cachePolygonRegion() {
                    if (this.polygonVertices.length < 3) {
                        alert('No polygon region defined.');
                        return;
                    }
                    
                    // Calculate the bounding box of the polygon
                    const bounds = this.getPolygonBounds();
                    
                    // Start progress tracking
                    this.cacheProgress.active = true;
                    this.cacheProgress.currentZoom = 17;
                    this.cacheProgress.maxZoom = 19;
                    this.cacheProgress.tilesProcessed = 0;
                    this.cacheProgress.newTilesCached = 0;
                    this.cacheProgress.alreadyCached = 0;
                    this.cacheProgress.status = 'Calculating tiles in polygon region...';
                    
                    // Calculate total tiles to process
                    let totalTiles = 0;
                    for (let z = 17; z <= 19; z++) {
                        const tiles = this.getTilesForBounds(bounds, z);
                        totalTiles += tiles.length;
                    }
                    
                    this.cacheProgress.totalTiles = totalTiles;
                    this.cacheProgress.status = `Found ${totalTiles} tiles to check in polygon region`;
                    
                    // Cache tiles for zoom levels 17-19 within the polygon bounds
                    await this.cacheTilesInBoundsWithProgress(bounds, 17, 19);
                    
                    // Clean up
                    this.cacheProgress.active = false;
                    this.clearPolygonLayers();
                    await this.getCacheStats();
                },
                
                getPolygonBounds() {
                    let minLat = Infinity, maxLat = -Infinity;
                    let minLng = Infinity, maxLng = -Infinity;
                    
                    this.polygonVertices.forEach(vertex => {
                        minLat = Math.min(minLat, vertex[0]);
                        maxLat = Math.max(maxLat, vertex[0]);
                        minLng = Math.min(minLng, vertex[1]);
                        maxLng = Math.max(maxLng, vertex[1]);
                    });
                    
                    return L.latLngBounds([minLat, minLng], [maxLat, maxLng]);
                },
                
                async cacheTilesInBoundsWithProgress(bounds, minZoom, maxZoom) {
                    let newTilesCached = 0;
                    let alreadyCached = 0;
                    
                    for (let z = minZoom; z <= maxZoom; z++) {
                        this.cacheProgress.currentZoom = z;
                        this.cacheProgress.status = `Processing zoom level ${z}...`;
                        
                        const tiles = this.getTilesForBounds(bounds, z);
                        
                        for (const tile of tiles) {
                            // Check if we should cancel
                            if (!this.cacheProgress.active) {
                                this.cacheProgress.status = 'Caching cancelled by user';
                                return;
                            }
                            
                            // Check if tile is within polygon
                            if (this.isTileInPolygon(tile, z)) {
                                // Check if already cached
                                const isCached = await this.checkTileCached(tile.z, tile.x, tile.y);
                                
                                if (isCached) {
                                    alreadyCached++;
                                } else {
                                    // Cache the tile
                                    const success = await this.cacheTile(tile.z, tile.x, tile.y);
                                    if (success) {
                                        newTilesCached++;
                                    }
                                }
                            }
                            
                            // Update progress
                            this.cacheProgress.tilesProcessed++;
                            this.cacheProgress.newTilesCached = newTilesCached;
                            this.cacheProgress.alreadyCached = alreadyCached;
                            this.cacheProgress.percentage = (this.cacheProgress.tilesProcessed / this.cacheProgress.totalTiles) * 100;
                            
                            // Small delay to prevent overwhelming the server
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                    }
                    
                    this.cacheProgress.status = `Completed! Cached ${newTilesCached} new tiles, ${alreadyCached} were already cached.`;
                },
                
                isTileInPolygon(tile, zoom) {
                    // Simplified check - just use the tile center
                    const tileCenter = this.tileToLatLng(tile.x, tile.y, zoom);
                    return this.pointInPolygon(tileCenter, this.polygonVertices);
                },
                
                tileToLatLng(x, y, zoom) {
                    const n = Math.pow(2, zoom);
                    const lng = x / n * 360 - 180;
                    const lat = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI;
                    return [lat, lng];
                },
                
                pointInPolygon(point, polygon) {
                    // Ray casting algorithm
                    let inside = false;
                    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                        if (((polygon[i][0] > point[0]) !== (polygon[j][0] > point[0])) &&
                            (point[1] < (polygon[j][1] - polygon[i][1]) * (point[0] - polygon[i][0]) / (polygon[j][0] - polygon[i][0]) + polygon[i][1])) {
                            inside = !inside;
                        }
                    }
                    return inside;
                }
            },
            mounted() {
                this.$nextTick(() => {
                    // Initialize map after DOM is fully rendered
                    this.map = L.map('map', {
                        // These options improve mobile handling
                        tap: true, // Enable tap handler for touch devices
                        dragging: !L.Browser.mobile, // Disable drag by default on mobile
                        tap: L.Browser.safari && L.Browser.mobile, // Use tap instead of click for Safari on iOS
                        bounceAtZoomLimits: false, // Don't bounce at zoom limits
                        touchZoom: 'center' // Center zoom on mobile touch
                    }).setView([9.2,-133], 10);
                    
                    // Enable dragging after a short delay (prevents scrolling issues)
                    if (L.Browser.mobile) {
                        setTimeout(() => {
                            this.map.dragging.enable();
                        }, 1000);
                    }
                    
                    this.createOfflineTileLayer().addTo(this.map);
                    
                    // Add scale control
                    L.control.scale({imperial: false}).addTo(this.map);
                    this.scaleAdded = true;
                    
                    // Add zoom change listener to update zoom display
                    this.map.on('zoomend', () => {
                        // Force Vue to update the zoom display
                        this.$forceUpdate();
                    });
                    
                    this.checkLoggingStatus();
                    this.getCacheStats();
                    this.getRecentCachedArea();
                    this.startCacheStatsRefresh();
                    this.loadMapSources();
                });
            }
        })
    </script>
</body>
</html>