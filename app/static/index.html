<!DOCTYPE html>
<html>
<head>
    <title>Simple Ping2 Survey Extension</title>
    <style>
        
        #logo-right, #logo-left {
        width: 100px;
        height: 100px;
        position: absolute;
        z-index: 1000;
        }
        #logo-right {
        top: 10px;
        right: 10px;
        }
        #logo-left {
        top: 10px;
        left: 10px;
        }
        .rotating-logo {
            position: absolute;
            width: 100px;
            height: 100px;
            transition: transform 0.5s ease-in-out;
            transform-origin: center;
            transform: rotate(0deg);
        }
        #app {
            margin-top: 60px; /* Adjust based on logo size and desired spacing */
        }
                .confidence-high {
            background-color: green;
            color: white;
            text-align: center;
        }

        .confidence-medium {
            background-color: yellow;
            color: black;
            text-align: center;
        }

        .confidence-low {
            background-color: red;
            color: white;
            text-align: center;
        }
    </style>
    <link href="/static/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="/static/css/vuetify.min.css" rel="stylesheet">
    <link href="/static/css/style.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/leaflet.css" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
</head>
<body>
 
<div id="app">
    <v-app>
        <v-main>
            <v-container>
                <h1>Simple Ping2 Survey Extension</h1>
                <v-btn :disabled="isLoading" outlined rounded text @click="toggleRun"><v-icon>{{ icon }}</v-icon></v-btn>
                <v-btn outlined rounded text @click="download">Download</v-btn>
                <rotating-logo id="logo-left" src="/static/BRlogo.png" :should-rotate="receivingData" class="rotating-logo"></rotating-logo>
                <rotating-logo id="logo-right" src="/static/BRlogo.png" :should-rotate="receivingData" class="rotating-logo"></rotating-logo>              
                <div id="map" style="width:100%; height: 70vh;"></div>
                <v-btn outlined rounded text @click="clearHeatmap">Clear Map</v-btn>
                <v-btn outlined rounded text @click="onCenterMapButtonClick">Center Map</v-btn>
                <div class="text-center">
                    <h4>Status Console</h4>
                </div>
                <!-- <div id="status-readout">{{ status }}</div> -->
                <v-data-table
                    :headers="tableHeaders"
                    :items="tableItems"
                    :hide-default-footer="true"
                    class="elevation-1"
                >
                <template v-slot:item.confidence="{ item }">
                    <td :class="getConfidenceClass(item.confidence)">
                        {{ item.confidence }}
                    </td>
                </template>
                </v-data-table>
            </v-container>
        </v-main>
    </v-app>
</div>

<script src="/static/js/vue.js"></script>
<script src="/static/js/vuetify.js"></script>
<script src="/static/js/axios.min.js"></script>
<script src="/static/js/chart.js"></script>
<script src="/static/js/leaflet.js"></script>
<script src="/static/js/leaflet.rotatedMarker.js"></script>
<script>
Vue.component('rotating-logo', {
  template: '<img :src="src" :style="styleObject" alt="Logo">',
  props: ['src', 'shouldRotate'],
  data: function () {
    return {
      rotationDegree: 0,
      styleObject: {
        position: 'absolute',
        transition: 'transform 0.5s',
        transformOrigin: 'center'
      }
    };
  },
  watch: {
  shouldRotate: function (newVal, oldVal) {
    if(newVal) {
      this.rotationDegree = (this.rotationDegree + 45) % 360;
    } else {
      // Optional: reset rotation when data stops being received
      // this.rotationDegree = 0;
    }
    console.log(this.rotationDegree)
    this.styleObject.transform = `rotate(${this.rotationDegree}deg)`;
  }
},
});
</script>
<script>
    Vue.config.devtools = true;
    new Vue({
        el: '#app',
        vuetify: new Vuetify({
            theme: {
                dark: true, // Enable light/dark mode
            },
        }),
        data() {
            return {
                status: "",
                firstCoordinateReceived: false,
                icon: 'mdi-play',
                run: false,
                map: null,
                circleMarkers: [],
                isLoading: false,
                receivingData: false,
                logoRotation: 0,
                customIcon: L.icon({
                iconUrl: '/static/BB.png',  // icon .png file
                iconSize: [32, 45],  // icon size in pixels
                iconAnchor: [12, 26],  // icon anchor coordinate (from bottom left?)
                className: 'leaflet-rotated-marker'
                }),
                zoomMode: true,
                randomNames: [
                    'Ocean_Opulence_Survey', 'Tidal_Tidbits_Collection', 'Seabed_Delights_Map',
                    'Benthic_Base_Basis', 'Whimsy_Wavy_Data', 'Infinite_Seas_Quantified',
                    'Tide_Tomfoolery_Tracking', 'Marine_Mirth_Measurements', 'Aqua_Antics_Archive',
                    'Coral_Comedy_Compilation', 'DeepDive_Doodles_Database', 'Seabed_Satire_Statistics',
                    'Water_Wisecracks_Warehouse', 'Benthic_Bellylaughs_Bank', 'Subsea_Smirk_Storage',
                    'Ping2_Polling_Places', 'BlueBoat_Big_Bundle', 'Wave_Wittiness_Warehouse',
                    'Maritime_Mockery_Metrics', 'Sonar_Search_Statistics', 'Hydro_Hilarity_History',
                    'Nautical_Notes_Nexus', 'Sea_Smiles_Storage', 'Pelagic_Plain_Profiles', 
                    'Sonar_Surf_Summary', 'Hydro_Humor_Holdings', 'Nautical_Nonsense_Notes', 
                    'Sea_Snickers_Statistics', 'Tidal_Titters_Trove', 'Marine_Musings_Metrics', 
                    'Aqua_Amusement_Archive', 'Coral_Capers_Compilation', 'DeepDive_Doodles_Database', 
                    'Seabed_Silliness_Storage', 'Water_Witticisms_Warehouse', 'Benthic_Banter_Bank', 
                    'Subsea_Snippets_Storage', 'Ping2_Playfulness_Pool', 'BlueBoat_Bellylaughs_Bundle', 
                    'Ocean_Oracles_Opulence', 'Sea_Snickers_Statistics','Maritime_Mirth_Measurements'
                    ],
                tableHeaders: [
                    { text: 'Latitude', value: 'latitude', align: 'center' },
                    { text: 'Longitude', value: 'longitude', align: 'center' },
                    { text: 'Depth (m)', value: 'depth', align: 'center' },
                    { text: 'Beam Coverage Diameter (m)', value: 'beamCoverageDiameter', align: 'center' },
                    { text: 'Confidence (%)', value: 'confidence', align: 'center' },
                    { text: 'Yaw (deg)', value: 'yaw', align: 'center' }
                ],
                tableItems: [],
            }
        },
        methods: {
            async toggleRun() {
                // Toggle the icon between play and stop
                this.icon = this.icon === 'mdi-play' ? 'mdi-stop' : 'mdi-play';
                this.run = !this.run;

                if (this.run) {
                    await this.start();
                } else {
                    await this.stop();
                }
            },

            async start() {
                try {
                    const response = await fetch('/start');
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    const data = await response.text();
                    this.status = 'Data logging started.'
                    this.receivingData = true;
                    this.status = data;
                } catch (error) {
                    console.error('Error fetching data:', error);
                    this.status = 'Error: ' + error.message;
                } 
                this.map.setView([9.2,-133], 13); 
                L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                maxZoom: 19,
                attribution: '&copy; <a href="https://www.google.com/maps">Google Maps</a>'
                }).addTo(this.map);
                this.intervalId = setInterval(this.fetchData, 1000); // fetch data every second
                L.control.scale({imperial: false}).addTo(map);
                console.log('Map:', this.map);
                
            },

            async stop() {
                try {
                    const response = await fetch('/stop');
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    const data = await response.text();
                    this.status = 'Data logging stopped.'
                    this.receivingData = false;
                } catch (error) {
                    console.error('Error fetching data:', error);
                    this.status = 'Error: ' + error.message;
                }
                clearInterval(this.intervalId);
            },

            async download() {
                try {
                    const response = await fetch('/download');
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const randomName = this.randomNames[Math.floor(Math.random() * this.randomNames.length)];   // Generate a random name from the list
                    const timestamp = new Date().toLocaleString('en-US', { month: '2-digit', day: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' }).replace(',', '');
                    const fileName = `${randomName}_finished_at_${timestamp}.csv`;   // Construct the new file name
                    const link = document.createElement('a');
                    link.href = url;
                    link.setAttribute('download', fileName);
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    this.status = `Data file downloaded: ${fileName}`;
                } catch (error) {
                    console.error('Error fetching data:', error);
                    this.status = 'Error: ' + error.message;
                }
            },

            async fetchData() {
                try {
                    const response = await axios.get('/data');
                    this.status = JSON.stringify(response.data);
                    
                    let angleRadians = (12.5 * Math.PI) / 180; // Convert angle from degrees to radians
                    let beamCoverageDiameter = ((2 * Math.atan(angleRadians) * response.data[3])/100).toFixed(2);
                    

                    this.tableItems = [{
                        latitude: response.data[6],
                        longitude: response.data[7],
                        depth: response.data[3]/ 100,  // Convert cm to meters
                        beamCoverageDiameter: beamCoverageDiameter,  // Calculated Beam Coverage Diameter
                        confidence: response.data[4],
                        yaw: response.data[5]
                        
                    }];

                    this.updateMarker(response.data[6], response.data[7], response.data[3], response.data[4], response.data[5]);
                    if (!this.firstCoordinateReceived) {
                        this.firstCoordinateReceived = true;
                        this.map.setView([response.data[6], response.data[7]], 18);
                    }
                } catch (error) {
                    console.error('Error fetching data:', error);
                    this.status = 'Error: ' + error.message;
                    console.log(response.data)
                }
            },
            
            updateMarker(lat, lon, depth, confidence, yaw) {
                if (this.marker) {    // Remove the old marker from the map
                    this.map.removeLayer(this.marker);
                }
                
                this.marker = L.marker([lat, lon], {
                    icon: this.customIcon, 
                    rotationAngle: yaw, 
                    rotationOrigin: 'center center'  // This line is necessary to rotate the marker from its center point
                });
                this.receivingData = !this.receivingData; // data received so rotate logos
                this.marker.addTo(this.map); // Update the map layer's data
                if (confidence > 90){   
                    const radiusInMeters = (depth/100) * Math.tan(12.5 * Math.PI / 180); // conver depth to Meter, 25degree beam angle is 12.5 degree, divide by pi/180 for radian to degree
                    const radius = radiusInMeters * this.map.getZoomScale(this.map.getZoom());
                    const circleMarker = L.circle([lat, lon], {
                    color: 'blue',
                    fillColor: this.getColor(depth),
                    fillOpacity: 0.5,
                    weight: 0,
                    radius: radius
                    });
                    circleMarker.addTo(this.map);
                    this.circleMarkers.push(circleMarker);
                }
            },
            clearHeatmap() {
                this.circleMarkers.forEach(circleMarker => {
                circleMarker.remove();
            });
            this.circleMarkers = [];
            },
            onCenterMapButtonClick() {
                this.firstCoordinateReceived = false;
            },
            getColor(depth) {
            const colorStops = [
                { depth: 0, color: [209, 233, 255] }, 
                { depth: 1000, color: [191, 2224,255 ] }, 
                { depth: 2000, color: [181, 215, 247] }, 
                { depth: 3000, color: [170, 207, 242] }, 
                { depth: 4000, color: [149, 188, 230] }, 
                { depth: 5000, color: [134, 179, 235] },
                { depth: 6000, color: [98, 159, 217] },
                { depth: 70000, color: [82, 143, 204] },
                { depth: 80000, color: [66, 124, 179] },
                { depth: 10000, color: [43, 102, 166] },  
                { depth: 10000, color: [56, 91, 140] }  
            ];
            let color1, color2;// Find the two colors we need to interpolate between
            for (let i = 0; i < colorStops.length - 1; i++) {
                if (depth >= colorStops[i].depth && depth <= colorStops[i + 1].depth) {
                    color1 = colorStops[i];
                    color2 = colorStops[i + 1];
                    break;
                }
            }
            if (!color1) { // If depth is out of range, use the first or last color stop
                return depth <= 0 ? `rgb(${colorStops[0].color})` : `rgb(${colorStops[colorStops.length - 1].color})`;
            }
            const t = (depth - color1.depth) / (color2.depth - color1.depth);// Interpolate between the two colors
            const color = color1.color.map((start, i) => {
                return Math.round(start + (color2.color[i] - start) * t);
            });
            return `rgb(${color})`;
            },
            getConfidenceClass(confidence) {
                if (confidence > 95) {
                    return 'confidence-high';
                } else if (confidence > 80) {
                    return 'confidence-medium';
                } else {
                    return 'confidence-low';
                }
            },
            async checkLoggingStatus() {
                try {
                    const response = await axios.get('/status');
                    if (response.data.logging_active) {
                        this.run = true;
                        this.icon = 'mdi-stop';
                        this.map.setView([9.2,-133], 13);
                        L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                        maxZoom: 21,
                        attribution: '&copy; <a href="https://www.google.com/maps">Google Maps</a>'
                        }).addTo(this.map);
                        this.intervalId = setInterval(this.fetchData, 500); // fetch data every second
                        console.log('Map:', this.map);
                    } else {
                        this.run = false;
                        this.icon = 'mdi-play';
                    }
                } catch (error) {
                    console.error('Error fetching status:', error);
                    this.run = false;
                    this.icon = 'mdi-play';
                }
            },
        },
        
        mounted() {
            this.checkLoggingStatus();
            this.map = L.map('map').setView([9.2,-133], 13);
            L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
            maxZoom: 21,
            attribution: '&copy; <a href="https://www.google.com/maps">Google Maps</a>'
            }).addTo(this.map);
            L.control.scale({imperial: false}).addTo(map);
            console.log('Vue App Mounted! Have a safe voyage!')
        }
    })

</script>
</body>
</html>
