<!DOCTYPE html>
<html>
<head>
    <title>Simple Ping Survey Extension</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            background-color: #121212;
            color: white;
            font-family: 'Roboto', Arial, sans-serif;
        }
        
        /* Fix for white bar issue */
        html, body {
            height: 100%;
            width: 100%;
        }
        
        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%;
        }
        
        .header {
            background-color: #1E1E1E;
            padding: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 10;
        }
        
        .title {
            text-align: center;
            flex-grow: 1;
            margin: 0;
            font-size: 1.5rem;
        }
        
        .logo {
            width: 40px;
            height: 40px;
            transition: transform 0.5s ease-in-out;
        }
        
        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative; /* For floating buttons */
        }
        
        .map-container {
            flex: 1;
            position: relative;
            min-height: 400px;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        /* Depth legend styles */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: 12px;
            width: 120px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .legend h4 {
            margin: 0 0 5px 0;
            text-align: center;
            font-size: 14px;
        }
        
        .legend-gradient {
            height: 150px;
            width: 30px;
            margin: 5px auto;
            background: linear-gradient(to bottom, 
                rgb(255, 255, 255) 0%,
                rgb(180, 210, 255) 20%,
                rgb(100, 150, 240) 40%,
                rgb(40, 90, 200) 60%,
                rgb(10, 30, 160) 80%,
                rgb(0, 0, 120) 100%);
            border: 1px solid #444;
        }
        
        .legend-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 140px;
            margin-left: 40px;
            margin-top: -145px;
            font-size: 11px;
        }
        
        /* Floating center map button for mobile */
        .map-center-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            background-color: rgba(33, 33, 33, 0.8);
            border-radius: 50%;
            width: 56px;
            height: 56px;
            display: none; /* Hidden by default, shown only on very small screens */
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap on small screens */
            gap: 8px;
            padding: 12px;
            background-color: #1E1E1E;
            justify-content: space-between; /* Distribute sections evenly */
        }
        
        .controls-section {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            align-items: center;
        }
        
        .status-panel {
            padding: 16px;
            background-color: #1E1E1E;
            margin-top: 1px;
            overflow-x: auto; /* Allow horizontal scrolling for the table */
        }
        
        .cache-progress-panel {
            padding: 16px;
            background-color: #1E1E1E;
            margin-top: 1px;
            border-top: 2px solid #9C27B0;
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        
        .progress-header h4 {
            margin: 0;
            color: #9C27B0;
        }
        
        .progress-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .progress-bar-container {
            margin-bottom: 8px;
        }
        
        .progress-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 14px;
        }
        
        .progress-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .progress-label {
            color: #888;
            font-weight: 500;
        }
        
        .progress-value {
            color: white;
            font-weight: 600;
        }
        
        /* Mobile responsiveness for progress panel */
        @media (max-width: 600px) {
            .progress-details {
                grid-template-columns: 1fr;
                gap: 6px;
                font-size: 12px;
            }
            
            .progress-header {
                flex-direction: column;
                gap: 8px;
                align-items: flex-start;
            }
            
            .cache-progress-panel {
                padding: 12px;
            }
        }
        
        .confidence-high {
            background-color: #4CAF50;
            color: white;
            text-align: center;
        }

        .confidence-medium {
            background-color: #FFC107;
            color: black;
            text-align: center;
        }

        .confidence-low {
            background-color: #F44336;
            color: white;
            text-align: center;
        }
        
        /* Fix for Vuetify layout issues */
        .v-application--wrap {
            min-height: 100vh;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 600px) {
            .controls {
                justify-content: center;
                flex-direction: column;
                gap: 16px;
            }
            
            .controls-section {
                width: 100%;
                justify-content: center;
            }
            
            .title {
                font-size: 1.2rem;
            }
            
            .logo {
                width: 30px;
                height: 30px;
            }
            
            .map-container {
                min-height: 300px; /* Smaller map on mobile */
            }
            
            .status-panel h4 {
                margin-top: 0;
                margin-bottom: 8px;
                font-size: 16px;
            }
            
            .status-panel {
                padding: 8px;
            }
            
            .v-data-table th, .v-data-table td {
                padding: 0 8px !important;
                font-size: 12px !important;
            }
            
            /* Show floating button on very small screens */
            @media (max-width: 400px) {
                .map-center-button {
                    display: flex;
                }
            }
            
            /* Mobile legend adjustments */
            .legend {
                width: 100px;
                font-size: 10px;
                bottom: 70px; /* Above the center button */
                left: 10px;
                padding: 5px;
            }
            
            .legend h4 {
                font-size: 12px;
            }
            
            .legend-gradient {
                height: 120px;
                width: 20px;
            }
            
            .legend-labels {
                height: 110px;
                margin-top: -115px;
                margin-left: 30px;
                font-size: 9px;
            }
        }
        
        /* Fix for map scrolling issues */
        .leaflet-container {
            touch-action: none;
        }
        
        /* Fix for table on mobile */
        .v-data-table {
            width: 100%;
            overflow-x: auto;
        }
    </style>
    <link href="/static/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="/static/css/vuetify.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/leaflet.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
</head>
<body>
    <div id="app">
        <v-app>
            <div class="header">
                <img class="logo" :class="{ 'rotate': receivingData }" src="/static/BRlogo.png" alt="Logo">
                <h1 class="title">Simple Ping Survey Extension</h1>
                <img class="logo" :class="{ 'rotate': receivingData }" src="/static/BRlogo.png" alt="Logo">
            </div>
            
            <div class="content">
                <div class="map-container">
                    <div id="map"></div>
                    <!-- Floating center map button for mobile -->
                    <div class="map-center-button" @click="onCenterMapButtonClick">
                        <v-icon color="white">mdi-crosshairs-gps</v-icon>
                    </div>
                    <!-- Depth legend -->
                    <div class="legend" v-if="showLegend">
                        <h4>Depth (m)</h4>
                        <div class="legend-gradient"></div>
                        <div class="legend-labels">
                            <span>0</span>
                            <span>20</span>
                            <span>40</span>
                            <span>60</span>
                            <span>80</span>
                            <span>100</span>
                        </div>
                    </div>
                </div>
                
                <div class="controls">
                    <!-- Left side - Start/Stop and Download -->
                    <div class="controls-section">
                        <v-btn :color="run ? 'error' : 'success'" :disabled="isLoading || simulation.active" 
                               dark rounded elevation="2" @click="toggleRun">
                            <v-icon left>{{ run ? 'mdi-stop' : 'mdi-play' }}</v-icon>
                            {{ run ? 'Stop' : 'Start' }}
                        </v-btn>
                        <v-btn color="primary" dark rounded elevation="2" @click="download">
                            <v-icon left>mdi-download</v-icon>
                            Download
                        </v-btn>
                    </div>
                    
                    <!-- Center section - Map Controls -->
                    <div class="controls-section">
                        <v-btn color="info" dark rounded elevation="2" @click="onCenterMapButtonClick">
                            <v-icon left>mdi-crosshairs-gps</v-icon>
                            Center
                        </v-btn>
                        <v-btn color="warning" dark rounded elevation="2" @click="clearHeatmap">
                            <v-icon left>mdi-delete</v-icon>
                            Clear
                        </v-btn>
                        <v-btn color="info" dark rounded elevation="2" @click="toggleLegend">
                            <v-icon left>mdi-{{ showLegend ? 'eye-off' : 'eye' }}</v-icon>
                            {{ showLegend ? 'Hide' : 'Show' }}
                        </v-btn>
                        <v-btn color="purple" dark rounded elevation="2" @click="cacheVisibleTiles" :loading="cacheLoading" :disabled="cacheProgress.active">
                            <v-icon left>mdi-cached</v-icon>
                            Cache: {{ cacheStats.cachedTiles }}
                        </v-btn>
                        <v-btn color="green" dark rounded elevation="2" @click="getRecentCachedArea" v-if="cacheStats.cachedTiles > 0">
                            <v-icon left>mdi-map-marker</v-icon>
                            Recent Area
                        </v-btn>
                        <v-btn color="blue" dark rounded elevation="2" @click="getCacheStats">
                            <v-icon left>mdi-refresh</v-icon>
                            Refresh
                        </v-btn>
                        <v-btn color="red" dark rounded elevation="2" @click="confirmClearCache">
                            <v-icon left>mdi-delete-sweep</v-icon>
                            Clear Cache
                        </v-btn>
                    </div>
                    
                    <!-- Right side - Simulation -->
                    <div class="controls-section">
                        <v-btn color="amber" :disabled="isLoading || run" dark rounded elevation="2" @click="toggleSimulation">
                            <v-icon left>{{ simulation.active ? 'mdi-stop' : 'mdi-play-circle-outline' }}</v-icon>
                            {{ simulation.active ? 'Stop Sim' : 'Start Sim (5x)' }}
                        </v-btn>
                    </div>
                </div>
                
                <!-- Cache Progress Bar -->
                <div v-if="cacheProgress.active" class="cache-progress-panel">
                    <div class="progress-header">
                        <h4>Cache Progress</h4>
                        <v-btn small color="error" @click="cancelCaching" :disabled="!cacheProgress.active">
                            <v-icon left>mdi-close</v-icon>
                            Cancel
                        </v-btn>
                    </div>
                    <div class="progress-content">
                        <div class="progress-bar-container">
                            <v-progress-linear
                                :value="cacheProgress.percentage"
                                color="purple"
                                height="25"
                                striped
                                stream
                            >
                                <template v-slot:default="{ value }">
                                    <strong>{{ Math.ceil(value) }}%</strong>
                                </template>
                            </v-progress-linear>
                        </div>
                        <div class="progress-details">
                            <div class="progress-row">
                                <span class="progress-label">Zoom Level:</span>
                                <span class="progress-value">{{ cacheProgress.currentZoom }} → {{ cacheProgress.maxZoom }}</span>
                            </div>
                            <div class="progress-row">
                                <span class="progress-label">Tiles Processed:</span>
                                <span class="progress-value">{{ cacheProgress.tilesProcessed }} / {{ cacheProgress.totalTiles }}</span>
                            </div>
                            <div class="progress-row">
                                <span class="progress-label">New Tiles Cached:</span>
                                <span class="progress-value">{{ cacheProgress.newTilesCached }}</span>
                            </div>
                            <div class="progress-row">
                                <span class="progress-label">Already Cached:</span>
                                <span class="progress-value">{{ cacheProgress.alreadyCached }}</span>
                            </div>
                            <div class="progress-row">
                                <span class="progress-label">Status:</span>
                                <span class="progress-value">{{ cacheProgress.status }}</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="status-panel">
                    <h4>Status Console</h4>
                    <v-data-table
                        :headers="tableHeaders"
                        :items="tableItems"
                        :hide-default-footer="true"
                        dense
                        class="elevation-1"
                    >
                    <template v-slot:item.confidence="{ item }">
                        <td :class="getConfidenceClass(item.confidence)">
                            {{ item.confidence }}
                        </td>
                    </template>
                    </v-data-table>
                </div>
            </div>
        </v-app>
    </div>

    <script src="/static/js/vue.js"></script>
    <script src="/static/js/vuetify.js"></script>
    <script src="/static/js/axios.min.js"></script>
    <script src="/static/js/leaflet.js"></script>
    <script src="/static/js/leaflet.rotatedMarker.js"></script>
    <script>
        new Vue({
            el: '#app',
            vuetify: new Vuetify({
                theme: {
                    dark: true,
                },
            }),
            data() {
                return {
                    status: "",
                    firstCoordinateReceived: false,
                    icon: 'mdi-play',
                    run: false,
                    map: null,
                    circleMarkers: [],
                    isLoading: false,
                    receivingData: false,
                    scaleAdded: false,
                    showLegend: true,
                    simulation: {
                        active: false,
                        dataRows: 0,
                        currentIndex: 0
                    },
                    cacheStats: {
                        cachedTiles: 0,
                        cacheSizeMB: 0,
                        cacheLimitMB: 5120
                    },
                    cacheLoading: false,
                    cacheProgress: {
                        active: false,
                        percentage: 0,
                        currentZoom: 0,
                        maxZoom: 0,
                        tilesProcessed: 0,
                        totalTiles: 0,
                        newTilesCached: 0,
                        alreadyCached: 0,
                        status: ''
                    },
                    cacheStatsRefreshTimeout: null,
                    cacheStatsInterval: null,
                    recentCachedArea: {
                        has_cached_tiles: false,
                        center_lat: 9.2,
                        center_lon: -133,
                        zoom: 10
                    },
                    customIcon: L.icon({
                        iconUrl: '/static/BB.png',
                        iconSize: [32, 45],
                        iconAnchor: [12, 26],
                        className: 'leaflet-rotated-marker'
                    }),
                    tableHeaders: [
                        { text: 'Latitude', value: 'latitude', align: 'center' },
                        { text: 'Longitude', value: 'longitude', align: 'center' },
                        { text: 'Depth (m)', value: 'depth', align: 'center' },
                        { text: 'Beam Coverage Diameter (m)', value: 'beamCoverageDiameter', align: 'center' },
                        { text: 'Confidence (%)', value: 'confidence', align: 'center' },
                        { text: 'Yaw (deg)', value: 'yaw', align: 'center' },
                        { text: 'Roll (deg)', value: 'roll', align: 'center' },
                        { text: 'Pitch (deg)', value: 'pitch', align: 'center' },
                        { text: 'Altitude (m)', value: 'altitude', align: 'center' }
                    ],
                    tableItems: [],
                    randomNames: [
                        'Ocean_Opulence_Survey', 'Tidal_Tidbits_Collection', 'Seabed_Delights_Map',
                        'Benthic_Base_Basis', 'Whimsy_Wavy_Data', 'Infinite_Seas_Quantified',
                        'Tide_Tomfoolery_Tracking', 'Marine_Mirth_Measurements', 'Aqua_Antics_Archive'
                    ]
                }
            },
            methods: {
                async toggleRun() {
                    this.icon = this.icon === 'mdi-play' ? 'mdi-stop' : 'mdi-play';
                    this.run = !this.run;
                    if (this.run) {
                        await this.start();
                    } else {
                        await this.stop();
                    }
                },
                async start() {
                    try {
                        const response = await fetch('/start');
                        if (!response.ok) {
                            throw new Error(`HTTP error! Status: ${response.status}`);
                        }
                        this.status = 'Data logging started.';
                        this.receivingData = true;
                        this.resetMap(9.2, -133, 10);
                        this.intervalId = setInterval(this.fetchData, 1000);
                    } catch (error) {
                        console.error('Error fetching data:', error);
                        this.status = 'Error: ' + error.message;
                    }
                },
                async stop() {
                    try {
                        const response = await fetch('/stop');
                        if (!response.ok) {
                            throw new Error(`HTTP error! Status: ${response.status}`);
                        }
                        this.status = 'Data logging stopped.';
                        this.receivingData = false; // Ensure animation stops
                        clearInterval(this.intervalId);
                    } catch (error) {
                        console.error('Error fetching data:', error);
                        this.status = 'Error: ' + error.message;
                    }
                },
                async download() {
                    try {
                        const response = await fetch('/download');
                        if (!response.ok) {
                            throw new Error(`HTTP error! Status: ${response.status}`);
                        }
                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const randomName = this.randomNames[Math.floor(Math.random() * this.randomNames.length)];
                        const timestamp = new Date().toLocaleString('en-US', { 
                            month: '2-digit', day: '2-digit', year: 'numeric', 
                            hour: '2-digit', minute: '2-digit', second: '2-digit' 
                        }).replace(',', '');
                        const fileName = `${randomName}_finished_at_${timestamp}.csv`;
                        const link = document.createElement('a');
                        link.href = url;
                        link.setAttribute('download', fileName);
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        this.status = `Data file downloaded: ${fileName}`;
                    } catch (error) {
                        console.error('Error fetching data:', error);
                        this.status = 'Error: ' + error.message;
                    }
                },
                async fetchData() {
                    try {
                        const response = await axios.get('/data');
                        this.status = JSON.stringify(response.data);
                        
                        // Make sure we have valid data to work with (should always be 11 points)
                        if (!response.data || !Array.isArray(response.data) || response.data.length < 11) {
                            console.error('Invalid data format received:', response.data);
                            return;
                        }
                        
                        let angleRadians = (12.5 * Math.PI) / 180;
                        let beamCoverageDiameter = ((2 * Math.atan(angleRadians) * response.data[3])/100).toFixed(2);
                        
                        // Ensure we handle both old and new data formats
                        const data = response.data;
                        const hasNewFormat = data.length >= 11;
                        
                        this.tableItems = [{
                            latitude: hasNewFormat ? data[8] : data[6],
                            longitude: hasNewFormat ? data[9] : data[7],
                            depth: data[3]/ 100,
                            beamCoverageDiameter: beamCoverageDiameter,
                            confidence: data[4],
                            yaw: data[5],
                            roll: hasNewFormat ? data[6] : 0,
                            pitch: hasNewFormat ? data[7] : 0,
                            altitude: hasNewFormat ? data[10] : 0
                        }];

                        // Use the correct lat/lon based on format
                        const lat = hasNewFormat ? data[8] : data[6];
                        const lon = hasNewFormat ? data[9] : data[7];
                        
                        this.updateMarker(lat, lon, data[3], data[4], data[5]);
                        
                        // Always center on GPS data if we haven't received coordinates yet
                        if (!this.firstCoordinateReceived) {
                            this.firstCoordinateReceived = true;
                            this.map.setView([lat, lon], 18);
                        }
                        
                        // Toggle animation only if still logging
                        if (this.run) {
                            this.receivingData = !this.receivingData;
                        }
                    } catch (error) {
                        console.error('Error fetching data:', error);
                        this.status = 'Error: ' + error.message;
                    }
                },
                updateMarker(lat, lon, depth, confidence, yaw) {
                    if (this.marker) {
                        this.map.removeLayer(this.marker);
                    }
                    
                    this.marker = L.marker([lat, lon], {
                        icon: this.customIcon, 
                        rotationAngle: yaw, 
                        rotationOrigin: 'center center'
                    });
                    this.marker.addTo(this.map);
                    
                    // Only show depth circles if we have valid ping data (confidence > 0)
                    if (confidence > 0) {   
                        const radiusInMeters = (depth/100) * Math.tan(12.5 * Math.PI / 180);
                        const radius = radiusInMeters * this.map.getZoomScale(this.map.getZoom());
                        const fillColor = this.getColor(depth);
                        
                        // Create a more visible circle with stronger border
                        const circleMarker = L.circle([lat, lon], {
                            color: 'black',       // Black outline for contrast against all colors
                            fillColor: fillColor,
                            fillOpacity: 0.7,     // Higher opacity for better visibility
                            weight: 1,           // Thin but visible border
                            radius: radius
                        });
                        circleMarker.addTo(this.map);
                        this.circleMarkers.push(circleMarker);
                    }
                },
                clearHeatmap() {
                    this.circleMarkers.forEach(circleMarker => {
                        circleMarker.remove();
                    });
                    this.circleMarkers = [];
                },
                onCenterMapButtonClick() {
                    this.firstCoordinateReceived = false;
                    
                    // If we have GPS data already, center on that
                    if (this.tableItems.length > 0) {
                        const item = this.tableItems[0];
                        this.resetMap(item.latitude, item.longitude, 18);
                    } else if (this.recentCachedArea.has_cached_tiles) {
                        // If we have cached tiles, center on the recent area
                        this.resetMap(this.recentCachedArea.center_lat, this.recentCachedArea.center_lon, this.recentCachedArea.zoom);
                    } else {
                        // Otherwise reset to default view
                        this.resetMap(9.2, -133, 10);
                    }
                },
                getColor(depth) {
                    const colorStops = [
                        {depth: 0, color: [255, 255, 255]},    // Pure white for shallow
                        {depth: 1000, color: [220, 230, 255]}, 
                        {depth: 2000, color: [180, 210, 255]},
                        {depth: 3000, color: [140, 180, 250]},
                        {depth: 4000, color: [100, 150, 240]},
                        {depth: 5000, color: [70, 120, 220]},
                        {depth: 6000, color: [40, 90, 200]},
                        {depth: 7000, color: [20, 60, 180]},
                        {depth: 8000, color: [10, 30, 160]},
                        {depth: 9000, color: [5, 15, 140]},
                        {depth: 10000, color: [0, 0, 120]}      // Dark blue for deep
                    ];
                    
                    // Add higher contrast to circles
                    const opacity = 0.7; // Higher opacity for better visibility
                    const strokeWeight = 1; // Add stroke to improve contrast
                    
                    let color1, color2;
                    for (let i = 0; i < colorStops.length - 1; i++) {
                        if (depth >= colorStops[i].depth && depth <= colorStops[i + 1].depth) {
                            color1 = colorStops[i];
                            color2 = colorStops[i + 1];
                            break;
                        }
                    }
                    
                    if (!color1) {
                        return depth <= 0 ? `rgb(${colorStops[0].color})` : `rgb(${colorStops[colorStops.length - 1].color})`;
                    }
                    
                    const t = (depth - color1.depth) / (color2.depth - color1.depth);
                    const color = color1.color.map((start, i) => {
                        return Math.round(start + (color2.color[i] - start) * t);
                    });
                    
                    return `rgb(${color})`;
                },
                getConfidenceClass(confidence) {
                    if (confidence > 95) return 'confidence-high';
                    if (confidence > 80) return 'confidence-medium';
                    return 'confidence-low';
                },
                async toggleSimulation() {
                    try {
                        this.isLoading = true;
                        if (!this.simulation.active) {
                            const response = await fetch('/start_simulation');
                            const result = await response.json();
                            if (result.success) {
                                this.simulation.active = true;
                                this.simulation.dataRows = result.data_rows || 0;
                                this.receivingData = true;
                                this.intervalId = setInterval(this.fetchData, 1000);
                                this.resetMap(9.2, -133, 10);
                                
                                // Get more detailed simulation status
                                const statusResponse = await fetch('/simulation_status');
                                const statusData = await statusResponse.json();
                                const formatMessage = statusData.data_format === "legacy" ? 
                                    " (legacy format - roll, pitch, altitude set to 0)" : 
                                    " (enhanced format with roll, pitch, altitude)";
                                
                                this.status = `Simulation started with ${result.data_rows} data points at 5x speed${formatMessage}`;
                            } else {
                                alert(`Failed to start simulation: ${result.message}`);
                            }
                        } else {
                            await fetch('/stop_simulation');
                            this.simulation.active = false;
                            this.receivingData = false;
                            clearInterval(this.intervalId);
                            this.status = 'Simulation stopped';
                        }
                    } catch (error) {
                        console.error('Simulation error:', error);
                        alert(`Simulation error: ${error.message}`);
                    } finally {
                        this.isLoading = false;
                    }
                },
                async checkLoggingStatus() {
                    try {
                        const response = await axios.get('/status');
                        if (response.data.logging_active) {
                            this.run = true;
                            this.icon = 'mdi-stop';
                            this.resetMap(9.2, -133, 10);
                            this.intervalId = setInterval(this.fetchData, 1000);
                        } else {
                            this.run = false;
                            this.icon = 'mdi-play';
                        }
                        
                        // Check simulation status
                        this.simulation.active = response.data.simulation_active || false;
                        if (this.simulation.active) {
                            this.intervalId = setInterval(this.fetchData, 1000);
                        }
                    } catch (error) {
                        console.error('Error fetching status:', error);
                        this.run = false;
                        this.icon = 'mdi-play';
                    }
                },
                resetMap(lat, lon, zoom) {
                    // Remove existing layers to prevent duplicate controls
                    if (this.map) {
                        this.map.eachLayer((layer) => {
                            if (layer instanceof L.TileLayer) {
                                this.map.removeLayer(layer);
                            }
                        });
                    
                        // Clear any existing controls including scale
                        const controls = this.map._controlCorners;
                        if (controls && controls.bottomleft) {
                            while (controls.bottomleft.firstChild) {
                                controls.bottomleft.removeChild(controls.bottomleft.firstChild);
                            }
                        }
                        
                        // Reset the map view
                        this.map.setView([lat, lon], zoom);
                        
                        // Fix mobile handling if needed
                        if (L.Browser.mobile) {
                            // Ensure touch handling is properly set
                            this.map.tap.enable();
                            // Disable dragging and re-enable after a slight delay
                            this.map.dragging.disable();
                            setTimeout(() => {
                                this.map.dragging.enable();
                            }, 500);
                        }
                        
                        // Add base layer with offline caching
                        this.createOfflineTileLayer().addTo(this.map);
                        
                        // Add fresh scale control
                        L.control.scale({imperial: false}).addTo(this.map);
                        this.scaleAdded = true;
                    }
                },
                toggleLegend() {
                    this.showLegend = !this.showLegend;
                },
                async getCacheStats() {
                    this.cacheLoading = true;
                    try {
                        const response = await fetch('/cache_stats');
                        const stats = await response.json();
                        console.log('Cache stats received:', stats);
                        // Convert backend snake_case to frontend camelCase
                        this.cacheStats = {
                            cachedTiles: stats.cached_tiles || 0,
                            cacheSizeMB: stats.cache_size_mb || 0,
                            cacheLimitMB: stats.cache_limit_mb || 5120
                        };
                        console.log('Cache stats converted:', this.cacheStats);
                    } catch (error) {
                        console.error('Error fetching cache stats:', error);
                        this.cacheStats = { cachedTiles: 0, cacheSizeMB: 0, cacheLimitMB: 5120 };
                    } finally {
                        this.cacheLoading = false;
                    }
                },
                async cacheVisibleTiles() {
                    if (!this.map) {
                        alert('Map not initialized');
                        return;
                    }
                    
                    // Initialize progress tracking
                    this.cacheProgress = {
                        active: true,
                        percentage: 0,
                        currentZoom: this.map.getZoom(),
                        maxZoom: 21,
                        tilesProcessed: 0,
                        totalTiles: 0,
                        newTilesCached: 0,
                        alreadyCached: 0,
                        status: 'Calculating tiles...'
                    };
                    
                    this.cacheLoading = true;
                    
                    try {
                        const bounds = this.map.getBounds();
                        const currentZoom = this.map.getZoom();
                        const maxZoom = 21; // Maximum zoom level
                        
                        console.log(`Caching tiles from zoom ${currentZoom} to ${maxZoom} for bounds:`, bounds);
                        
                        let totalTiles = 0;
                        let newTilesCached = 0;
                        let alreadyCached = 0;
                        
                        // Calculate total tiles first
                        this.cacheProgress.status = 'Calculating total tiles...';
                        for (let z = currentZoom; z <= maxZoom; z++) {
                            const tiles = this.getTilesForBounds(bounds, z);
                            totalTiles += tiles.length;
                        }
                        
                        this.cacheProgress.totalTiles = totalTiles;
                        this.cacheProgress.status = `Starting cache process for ${totalTiles} tiles...`;
                        
                        // Cache tiles for each zoom level from current to max
                        for (let z = currentZoom; z <= maxZoom; z++) {
                            this.cacheProgress.currentZoom = z;
                            this.cacheProgress.status = `Processing zoom level ${z}...`;
                            
                            const tiles = this.getTilesForBounds(bounds, z);
                            console.log(`Zoom ${z}: ${tiles.length} tiles to check/cache`);
                            
                            // Skip if no tiles to process
                            if (tiles.length === 0) {
                                console.log(`No tiles for zoom ${z}, skipping`);
                                continue;
                            }
                            
                                                            // Process tiles in batches to avoid overwhelming the server
                                const batchSize = 5;
                                for (let i = 0; i < tiles.length; i += batchSize) {
                                    // Check if caching was cancelled
                                    if (!this.cacheProgress.active) {
                                        console.log('Caching cancelled by user');
                                        return;
                                    }
                                    
                                    const batch = tiles.slice(i, i + batchSize);
                                    
                                    // Check which tiles are already cached
                                    const checkPromises = batch.map(tile => this.checkTileCached(tile.z, tile.x, tile.y));
                                    const checkResults = await Promise.allSettled(checkPromises);
                                    
                                    // Filter out already cached tiles
                                    const tilesToCache = [];
                                    for (let j = 0; j < batch.length; j++) {
                                        const result = checkResults[j];
                                        if (result.status === 'fulfilled' && !result.value) {
                                            tilesToCache.push(batch[j]);
                                        } else if (result.status === 'fulfilled' && result.value) {
                                            alreadyCached++;
                                        }
                                    }
                                    
                                    console.log(`Batch ${Math.floor(i/batchSize) + 1}: ${tilesToCache.length} new tiles to cache, ${batch.length - tilesToCache.length} already cached`);
                                    
                                    // Cache only new tiles
                                    if (tilesToCache.length > 0) {
                                        const cachePromises = tilesToCache.map(tile => this.cacheTile(tile.z, tile.x, tile.y));
                                        const cacheResults = await Promise.allSettled(cachePromises);
                                        
                                        // Count successful caches
                                        newTilesCached += cacheResults.filter(r => r.status === 'fulfilled' && r.value).length;
                                    }
                                    
                                    // Update progress
                                    this.cacheProgress.tilesProcessed += batch.length;
                                    this.cacheProgress.newTilesCached = newTilesCached;
                                    this.cacheProgress.alreadyCached = alreadyCached;
                                    this.cacheProgress.percentage = (this.cacheProgress.tilesProcessed / this.cacheProgress.totalTiles) * 100;
                                    this.cacheProgress.status = `Processing batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(tiles.length/batchSize)} (${this.cacheProgress.tilesProcessed}/${this.cacheProgress.totalTiles} tiles)`;
                                    
                                    // Update cache stats every few batches
                                    if (i % (batchSize * 3) === 0) {
                                        await this.getCacheStats();
                                    }
                                    
                                    // Small delay to avoid overwhelming the server
                                    await new Promise(resolve => setTimeout(resolve, 200));
                                }
                        }
                        
                        console.log(`Caching complete: ${newTilesCached} new tiles cached, ${alreadyCached} already cached, ${totalTiles} total processed`);
                        await this.getCacheStats();
                        
                        // Update final progress
                        this.cacheProgress.percentage = 100;
                        this.cacheProgress.status = 'Caching complete!';
                        
                        // Show completion message
                        setTimeout(() => {
                            alert(`Caching complete!\n\n${newTilesCached} new tiles cached\n${alreadyCached} tiles already cached\nTotal tiles processed: ${totalTiles}\nZoom levels: ${currentZoom} to ${maxZoom}`);
                            
                            // Hide progress panel after a delay
                            setTimeout(() => {
                                this.cacheProgress.active = false;
                            }, 3000);
                        }, 500);
                        
                    } catch (error) {
                        console.error('Error caching visible tiles:', error);
                        this.cacheProgress.status = 'Error: ' + error.message;
                        alert('Error caching tiles: ' + error.message);
                    } finally {
                        this.cacheLoading = false;
                        if (this.cacheProgress.active) {
                            // Keep progress panel visible for a moment to show error
                            setTimeout(() => {
                                this.cacheProgress.active = false;
                            }, 5000);
                        }
                    }
                },
                getTilesForBounds(bounds, zoom) {
                    const tiles = [];
                    const north = bounds.getNorth();
                    const south = bounds.getSouth();
                    const east = bounds.getEast();
                    const west = bounds.getWest();
                    
                    console.log(`Bounds for zoom ${zoom}:`, { north, south, east, west });
                    
                    // Convert bounds to tile coordinates
                    const northWestTile = this.latLngToTile(north, west, zoom);
                    const southEastTile = this.latLngToTile(south, east, zoom);
                    
                    // Ensure we get the correct min/max tile coordinates
                    const minX = Math.floor(Math.min(northWestTile.x, southEastTile.x));
                    const maxX = Math.ceil(Math.max(northWestTile.x, southEastTile.x));
                    const minY = Math.floor(Math.min(northWestTile.y, southEastTile.y));
                    const maxY = Math.ceil(Math.max(northWestTile.y, southEastTile.y));
                    
                    console.log(`Tile bounds for zoom ${zoom}:`, { minX, maxX, minY, maxY });
                    
                    // Generate all tile coordinates in the bounds
                    for (let y = minY; y <= maxY; y++) {
                        for (let x = minX; x <= maxX; x++) {
                            tiles.push({ z: zoom, x: x, y: y });
                        }
                    }
                    
                    console.log(`Generated ${tiles.length} tiles for zoom ${zoom}`);
                    return tiles;
                },
                latLngToTile(lat, lng, zoom) {
                    const n = Math.pow(2, zoom);
                    const x = ((lng + 180) / 360) * n;
                    const y = (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * n;
                    return { x: x, y: y };
                },
                async checkTileCached(z, x, y) {
                    try {
                        const response = await fetch(`/tile_cached/${z}/${x}/${y}`);
                        const data = await response.json();
                        return data.cached;
                    } catch (error) {
                        console.error(`Error checking if tile ${z}/${x}/${y} is cached:`, error);
                        return false;
                    }
                },
                async cacheTile(z, x, y) {
                    try {
                        console.log(`Attempting to cache tile: ${z}/${x}/${y}`);
                        const response = await fetch(`/tiles/${z}/${x}/${y}.png`);
                        const success = response.ok;
                        console.log(`Tile ${z}/${x}/${y} cache result: ${success ? 'SUCCESS' : 'FAILED'} (${response.status})`);
                        return success;
                    } catch (error) {
                        console.error(`Error caching tile ${z}/${x}/${y}:`, error);
                        return false;
                    }
                },
                async confirmClearCache() {
                    // Get current cache stats first
                    await this.getCacheStats();
                    
                    if (this.cacheStats.cachedTiles === 0) {
                        alert('No tiles are currently cached.');
                        return;
                    }
                    
                    const message = `Are you sure you want to clear the cache?\n\nThis will remove ${this.cacheStats.cachedTiles} cached tiles.\n\nThis action cannot be undone.`;
                    
                    if (confirm(message)) {
                        await this.clearCache();
                    }
                },
                async clearCache() {
                    try {
                        const response = await fetch('/clear_cache');
                        const result = await response.json();
                        alert(result.message);
                        await this.getCacheStats();
                    } catch (error) {
                        console.error('Error clearing cache:', error);
                        alert('Error clearing cache');
                    }
                },
                createOfflineTileLayer() {
                    // Create a custom tile layer that uses our offline-capable backend
                    const tileLayer = L.tileLayer('/tiles/{z}/{x}/{y}.png', {
                        maxZoom: 21,
                        attribution: '&copy; <a href="https://www.google.com/maps">Google Maps</a> (Offline Cached)',
                        errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7' // Transparent tile for missing tiles
                    });
                    
                    // Refresh cache stats when tiles are loaded
                    tileLayer.on('tileload', () => {
                        // Debounce cache stats refresh to avoid too many requests
                        if (this.cacheStatsRefreshTimeout) {
                            clearTimeout(this.cacheStatsRefreshTimeout);
                        }
                        this.cacheStatsRefreshTimeout = setTimeout(() => {
                            this.getCacheStats();
                        }, 2000); // Refresh after 2 seconds of inactivity
                    });
                    
                    return tileLayer;
                },
                startCacheStatsRefresh() {
                    // Refresh cache stats every 30 seconds
                    this.cacheStatsInterval = setInterval(() => {
                        this.getCacheStats();
                    }, 30000);
                },
                stopCacheStatsRefresh() {
                    if (this.cacheStatsInterval) {
                        clearInterval(this.cacheStatsInterval);
                        this.cacheStatsInterval = null;
                    }
                },
                async getRecentCachedArea() {
                    try {
                        const response = await fetch('/recent_cached_area');
                        const data = await response.json();
                        this.recentCachedArea = data;
                        
                        // If we have cached tiles, center the map on the most recent area
                        if (data.has_cached_tiles && this.map) {
                            this.map.setView([data.center_lat, data.center_lon], data.zoom);
                            console.log(`Centered map on recent cached area: ${data.center_lat}, ${data.center_lon} at zoom ${data.zoom}`);
                        }
                    } catch (error) {
                        console.error('Error fetching recent cached area:', error);
                    }
                },
                cancelCaching() {
                    this.cacheProgress.active = false;
                    this.cacheProgress.status = 'Cancelled by user';
                    this.cacheLoading = false;
                    console.log('Caching cancelled by user');
                }
            },
            mounted() {
                this.$nextTick(() => {
                    // Initialize map after DOM is fully rendered
                    this.map = L.map('map', {
                        // These options improve mobile handling
                        tap: true, // Enable tap handler for touch devices
                        dragging: !L.Browser.mobile, // Disable drag by default on mobile
                        tap: L.Browser.safari && L.Browser.mobile, // Use tap instead of click for Safari on iOS
                        bounceAtZoomLimits: false, // Don't bounce at zoom limits
                        touchZoom: 'center' // Center zoom on mobile touch
                    }).setView([9.2,-133], 10);
                    
                    // Enable dragging after a short delay (prevents scrolling issues)
                    if (L.Browser.mobile) {
                        setTimeout(() => {
                            this.map.dragging.enable();
                        }, 1000);
                    }
                    
                    this.createOfflineTileLayer().addTo(this.map);
                    
                    // Add scale control
                    L.control.scale({imperial: false}).addTo(this.map);
                    this.scaleAdded = true;
                    
                    // Add CSS for logo rotation
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes spin {
                            from { transform: rotate(0deg); }
                            to { transform: rotate(360deg); }
                        }
                        .rotate {
                            animation: spin 2s linear infinite;
                        }
                    `;
                    document.head.appendChild(style);
                    
                    this.checkLoggingStatus();
                    this.getCacheStats();
                    this.getRecentCachedArea();
                    this.startCacheStatsRefresh();
                });
            }
        })
    </script>
</body>
</html>
