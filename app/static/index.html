<!DOCTYPE html>
<html>
<head>
    <title>Simple Ping Survey Extension</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow-x: hidden;
            background-color: #121212;
            color: white;
            font-family: 'Roboto', Arial, sans-serif;
        }
        
        /* Fix for white bar issue */
        html, body {
            height: 100%;
            width: 100%;
        }
        
        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%;
        }
        
        .header {
            background-color: #1E1E1E;
            padding: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 10;
        }
        
        .title {
            text-align: center;
            flex-grow: 1;
            margin: 0;
            font-size: 1.5rem;
        }
        
        .logo {
            width: 40px;
            height: 40px;
            transition: transform 0.5s ease-in-out;
        }
        
        .content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative; /* For floating buttons */
        }
        
        .map-container {
            position: relative;
            height: calc(100% - 150px);
            width: 100%;
            z-index: 1;
            overflow: hidden;
        }
        
        #map {
            height: 100%;
            width: 100%;
            background-color: #333;
        }
        
        /* Depth legend styles */
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            font-size: 12px;
            width: 120px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .legend h4 {
            margin: 0 0 5px 0;
            text-align: center;
            font-size: 14px;
        }
        
        .legend-gradient {
            height: 150px;
            width: 30px;
            margin: 5px auto;
            background: linear-gradient(to bottom, 
                rgb(255, 255, 255) 0%,
                rgb(180, 210, 255) 20%,
                rgb(100, 150, 240) 40%,
                rgb(40, 90, 200) 60%,
                rgb(10, 30, 160) 80%,
                rgb(0, 0, 120) 100%);
            border: 1px solid #444;
        }
        
        .legend-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 140px;
            margin-left: 40px;
            margin-top: -145px;
            font-size: 11px;
        }
        
        /* Floating center map button for mobile */
        .map-center-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            background-color: rgba(33, 33, 33, 0.8);
            border-radius: 50%;
            width: 56px;
            height: 56px;
            display: none; /* Hidden by default, shown only on very small screens */
            align-items: center;
            justify-content: center;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap; /* Allow buttons to wrap on small screens */
            gap: 8px;
            padding: 12px;
            background-color: #1E1E1E;
            justify-content: space-between; /* Distribute sections evenly */
        }
        
        .controls-section {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            align-items: center;
        }
        
        .status-panel {
            padding: 16px;
            background-color: #1E1E1E;
            margin-top: 1px;
            overflow-x: auto; /* Allow horizontal scrolling for the table */
        }
        
        .confidence-high {
            background-color: #4CAF50;
            color: white;
            text-align: center;
        }

        .confidence-medium {
            background-color: #FFC107;
            color: black;
            text-align: center;
        }

        .confidence-low {
            background-color: #F44336;
            color: white;
            text-align: center;
        }
        
        /* Fix for Vuetify layout issues */
        .v-application--wrap {
            min-height: 100vh;
        }
        
        /* Mobile adjustments */
        @media (max-width: 600px) {
            .title-container {
                padding: 10px 5px;
                justify-content: center;
            }
            
            .title {
                font-size: 18px;
            }
            
            .logo {
                height: 24px;
                margin-right: 5px;
            }
            
            .map-container {
                height: calc(100% - 200px);
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
                gap: 10px;
                padding: 10px 0;
            }
            
            .controls-section {
                justify-content: center;
                width: 100%;
            }
            
            .status-panel {
                padding: 5px;
            }
            
            .depth-legend {
                right: 5px;
                bottom: 60px;
                width: 30px;
                max-height: 200px;
            }
            
            .depth-text {
                font-size: 10px;
            }
        }
        
        /* Very small screens - show floating button */
        @media (max-width: 400px) {
            .map-center-button {
                display: block;
            }
            
            .map-container {
                height: calc(100% - 220px);
            }
        }
        
        /* Fix for map scrolling issues */
        .leaflet-container {
            background-color: #333 !important;
            height: 100% !important;
            width: 100% !important;
        }
        
        /* Ensure the map tiles render */
        .leaflet-tile-container {
            z-index: 5;
        }
        
        /* Fix for table on mobile */
        .v-data-table {
            width: 100%;
            overflow-x: auto;
        }
        
        /* Force leaflet panes to be visible */
        .leaflet-pane {
            z-index: 10 !important;
        }
        
        .leaflet-overlay-pane {
            z-index: 11 !important;
        }
        
        .leaflet-marker-pane {
            z-index: 12 !important;
        }
        
        /* Logo rotation animation */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .rotate {
            animation: spin 2s linear infinite;
        }
    </style>
    <link href="/static/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="/static/css/vuetify.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/leaflet.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
</head>
<body>
    <div id="app">
        <v-app>
            <div class="header">
                <img class="logo" :class="{ 'rotate': receivingData }" src="/static/BRlogo.png" alt="Logo">
                <h1 class="title">Simple Ping Survey Extension</h1>
                <img class="logo" :class="{ 'rotate': receivingData }" src="/static/BRlogo.png" alt="Logo">
            </div>
            
            <div class="content">
                <div class="map-container">
                    <div id="map"></div>
                    <!-- Floating center map button for mobile -->
                    <div class="map-center-button" @click="onCenterMapButtonClick">
                        <v-icon color="white">mdi-crosshairs-gps</v-icon>
                    </div>
                    <!-- Depth legend -->
                    <div class="legend" v-if="showLegend">
                        <h4>Depth (m)</h4>
                        <div class="legend-gradient"></div>
                        <div class="legend-labels">
                            <span>0</span>
                            <span>20</span>
                            <span>40</span>
                            <span>60</span>
                            <span>80</span>
                            <span>100</span>
                        </div>
                    </div>
                </div>
                
                <div class="controls">
                    <!-- Left side - Start/Stop and Download -->
                    <div class="controls-section">
                        <v-btn :color="run ? 'error' : 'success'" :disabled="isLoading || simulation.active" 
                               dark rounded elevation="2" @click="toggleRun">
                            <v-icon left>{{ run ? 'mdi-stop' : 'mdi-play' }}</v-icon>
                            {{ run ? 'Stop' : 'Start' }}
                        </v-btn>
                        <v-btn color="primary" dark rounded elevation="2" @click="download">
                            <v-icon left>mdi-download</v-icon>
                            Download
                        </v-btn>
                    </div>
                    
                    <!-- Center section - Map Controls -->
                    <div class="controls-section">
                        <v-btn color="info" dark rounded elevation="2" @click="onCenterMapButtonClick">
                            <v-icon left>mdi-crosshairs-gps</v-icon>
                            Center
                        </v-btn>
                        <v-btn color="warning" dark rounded elevation="2" @click="clearHeatmap">
                            <v-icon left>mdi-delete</v-icon>
                            Clear
                        </v-btn>
                        <v-btn color="info" dark rounded elevation="2" @click="toggleLegend">
                            <v-icon left>mdi-{{ showLegend ? 'eye-off' : 'eye' }}</v-icon>
                            {{ showLegend ? 'Hide' : 'Show' }}
                        </v-btn>
                    </div>
                    
                    <!-- Right side - Simulation -->
                    <div class="controls-section">
                        <v-btn color="amber" :disabled="isLoading || run" dark rounded elevation="2" @click="toggleSimulation">
                            <v-icon left>{{ simulation.active ? 'mdi-stop' : 'mdi-play-circle-outline' }}</v-icon>
                            {{ simulation.active ? 'Stop Sim' : 'Start Sim (5x)' }}
                        </v-btn>
                    </div>
                </div>
                
                <div class="status-panel">
                    <h4>Status Console</h4>
                    <v-data-table
                        :headers="tableHeaders"
                        :items="tableItems"
                        :hide-default-footer="true"
                        dense
                        class="elevation-1"
                    >
                    <template v-slot:item.confidence="{ item }">
                        <td :class="getConfidenceClass(item.confidence)">
                            {{ item.confidence }}
                        </td>
                    </template>
                    </v-data-table>
                </div>
            </div>
        </v-app>
    </div>

    <script src="/static/js/vue.js"></script>
    <script src="/static/js/vuetify.js"></script>
    <script src="/static/js/axios.min.js"></script>
    <script src="/static/js/leaflet.js"></script>
    <script src="/static/js/leaflet.rotatedMarker.js"></script>
    <script>
        new Vue({
            el: '#app',
            vuetify: new Vuetify({
                theme: {
                    dark: true,
                },
            }),
            data() {
                return {
                    logging: false,
                    simulating: false,
                    status: 'Ready',
                    map: null,
                    scaleAdded: false,
                    showLegend: true,
                    tableItems: [],
                    headers: [
                        {text: 'Time', value: 'timestamp', sortable: false},
                        {text: 'Lat', value: 'latitude', sortable: false},
                        {text: 'Long', value: 'longitude', sortable: false},
                        {text: 'Depth (m)', value: 'depth', sortable: false}
                    ],
                    run: false,
                    icon: 'mdi-play',
                    vehicleMarker: null,
                    heatLayer: null,
                    depthLayer: null,
                    datasetNames: [
                        'Mariana_Trench_Survey', 'Baltic_Sea_Expedition', 'Great_Barrier_Reef_Mapping',
                        'Benthic_Base_Basis', 'Whimsy_Wavy_Data', 'Infinite_Seas_Quantified',
                        'Tide_Tomfoolery_Tracking', 'Marine_Mirth_Measurements', 'Aqua_Antics_Archive'
                    ],
                    vehicleMarker: null,
                    heatLayer: null,
                    depthLayer: null,
                    isWidget: false,
                    firstMapCentered: false,
                    ws: null,
                    connected: false,
                    firstCoordinateReceived: false
                }
            },
            methods: {
                async toggleRun() {
                    this.icon = this.icon === 'mdi-play' ? 'mdi-stop' : 'mdi-play';
                    this.run = !this.run;
                    if (this.run) {
                        await this.start();
                    } else {
                        await this.stop();
                    }
                },
                async start() {
                    try {
                        const response = await fetch('/start');
                        if (!response.ok) {
                            throw new Error(`HTTP error! Status: ${response.status}`);
                        }
                        this.status = 'Data logging started.';
                        this.receivingData = true;
                        this.resetMap(9.2, -133, 10);
                        this.intervalId = setInterval(this.fetchData, 1000);
                    } catch (error) {
                        console.error('Error fetching data:', error);
                        this.status = 'Error: ' + error.message;
                    }
                },
                async stop() {
                    try {
                        const response = await fetch('/stop');
                        if (!response.ok) {
                            throw new Error(`HTTP error! Status: ${response.status}`);
                        }
                        this.status = 'Data logging stopped.';
                        this.receivingData = false; // Ensure animation stops
                        clearInterval(this.intervalId);
                    } catch (error) {
                        console.error('Error fetching data:', error);
                        this.status = 'Error: ' + error.message;
                    }
                },
                async download() {
                    try {
                        const response = await fetch('/download');
                        if (!response.ok) {
                            throw new Error(`HTTP error! Status: ${response.status}`);
                        }
                        const blob = await response.blob();
                        const url = window.URL.createObjectURL(blob);
                        const randomName = this.randomNames[Math.floor(Math.random() * this.randomNames.length)];
                        const timestamp = new Date().toLocaleString('en-US', { 
                            month: '2-digit', day: '2-digit', year: 'numeric', 
                            hour: '2-digit', minute: '2-digit', second: '2-digit' 
                        }).replace(',', '');
                        const fileName = `${randomName}_finished_at_${timestamp}.csv`;
                        const link = document.createElement('a');
                        link.href = url;
                        link.setAttribute('download', fileName);
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        this.status = `Data file downloaded: ${fileName}`;
                    } catch (error) {
                        console.error('Error fetching data:', error);
                        this.status = 'Error: ' + error.message;
                    }
                },
                async fetchData() {
                    try {
                        const response = await axios.get('/data');
                        this.status = JSON.stringify(response.data);
                        
                        // Make sure we have valid data to work with
                        if (!response.data || !Array.isArray(response.data) || response.data.length < 8) {
                            console.error('Invalid data format received:', response.data);
                            return;
                        }
                        
                        let angleRadians = (12.5 * Math.PI) / 180;
                        let beamCoverageDiameter = ((2 * Math.atan(angleRadians) * response.data[3])/100).toFixed(2);
                        
                        // Ensure we handle both old and new data formats
                        const data = response.data;
                        const hasNewFormat = data.length >= 11;
                        
                        this.tableItems = [{
                            latitude: hasNewFormat ? data[8] : data[6],
                            longitude: hasNewFormat ? data[9] : data[7],
                            depth: data[3]/ 100,
                            beamCoverageDiameter: beamCoverageDiameter,
                            confidence: data[4],
                            yaw: data[5],
                            roll: hasNewFormat ? data[6] : 0,
                            pitch: hasNewFormat ? data[7] : 0,
                            altitude: hasNewFormat ? data[10] : 0
                        }];

                        // Use the correct lat/lon based on format
                        const lat = hasNewFormat ? data[8] : data[6];
                        const lon = hasNewFormat ? data[9] : data[7];
                        
                        this.updateMarker(lat, lon, data[3], data[4], data[5]);
                        if (!this.firstCoordinateReceived) {
                            this.firstCoordinateReceived = true;
                            this.map.setView([lat, lon], 18);
                        }
                        
                        // Toggle animation only if still logging
                        if (this.run) {
                            this.receivingData = !this.receivingData;
                        }
                    } catch (error) {
                        console.error('Error fetching data:', error);
                        this.status = 'Error: ' + error.message;
                    }
                },
                updateMarker(lat, lon, depth, confidence, yaw) {
                    if (this.marker) {
                        this.map.removeLayer(this.marker);
                    }
                    
                    this.marker = L.marker([lat, lon], {
                        icon: this.customIcon, 
                        rotationAngle: yaw, 
                        rotationOrigin: 'center center'
                    });
                    this.marker.addTo(this.map);
                    
                    if (confidence > 90) {   
                        const radiusInMeters = (depth/100) * Math.tan(12.5 * Math.PI / 180);
                        const radius = radiusInMeters * this.map.getZoomScale(this.map.getZoom());
                        const fillColor = this.getColor(depth);
                        
                        // Create a more visible circle with stronger border
                        const circleMarker = L.circle([lat, lon], {
                            color: 'black',       // Black outline for contrast against all colors
                            fillColor: fillColor,
                            fillOpacity: 0.7,     // Higher opacity for better visibility
                            weight: 1,           // Thin but visible border
                            radius: radius
                        });
                        circleMarker.addTo(this.map);
                        this.circleMarkers.push(circleMarker);
                    }
                },
                clearHeatmap() {
                    this.circleMarkers.forEach(circleMarker => {
                        circleMarker.remove();
                    });
                    this.circleMarkers = [];
                },
                onCenterMapButtonClick() {
                    this.firstCoordinateReceived = false;
                    
                    // If we have data already, center on that
                    if (this.tableItems.length > 0) {
                        const item = this.tableItems[0];
                        // Center with offset to account for UI elements
                        this.centerMapOnPosition(item.latitude, item.longitude);
                    } else {
                        // Otherwise reset to default view
                        this.resetMap(9.2, -133, 10);
                    }
                },
                
                centerMapOnPosition(lat, lon) {
                    if (!this.map) return;
                    
                    // Get the map container size
                    const mapSize = this.map.getSize();
                    
                    // Calculate point with offset to center the marker in the visible area
                    // Offset upward to account for controls at the bottom
                    const targetPoint = this.map.project([lat, lon], 18)
                                         .subtract([0, -mapSize.y * 0.15]); // Offset upward by 15% of height
                    
                    // Convert back to lat/lon and set view
                    const targetLatLng = this.map.unproject(targetPoint, 18);
                    this.resetMap(targetLatLng.lat, targetLatLng.lng, 18);
                },
                getColor(depth) {
                    const colorStops = [
                        {depth: 0, color: [255, 255, 255]},    // Pure white for shallow
                        {depth: 1000, color: [220, 230, 255]}, 
                        {depth: 2000, color: [180, 210, 255]},
                        {depth: 3000, color: [140, 180, 250]},
                        {depth: 4000, color: [100, 150, 240]},
                        {depth: 5000, color: [70, 120, 220]},
                        {depth: 6000, color: [40, 90, 200]},
                        {depth: 7000, color: [20, 60, 180]},
                        {depth: 8000, color: [10, 30, 160]},
                        {depth: 9000, color: [5, 15, 140]},
                        {depth: 10000, color: [0, 0, 120]}      // Dark blue for deep
                    ];
                    
                    // Add higher contrast to circles
                    const opacity = 0.7; // Higher opacity for better visibility
                    const strokeWeight = 1; // Add stroke to improve contrast
                    
                    let color1, color2;
                    for (let i = 0; i < colorStops.length - 1; i++) {
                        if (depth >= colorStops[i].depth && depth <= colorStops[i + 1].depth) {
                            color1 = colorStops[i];
                            color2 = colorStops[i + 1];
                            break;
                        }
                    }
                    
                    if (!color1) {
                        return depth <= 0 ? `rgb(${colorStops[0].color})` : `rgb(${colorStops[colorStops.length - 1].color})`;
                    }
                    
                    const t = (depth - color1.depth) / (color2.depth - color1.depth);
                    const color = color1.color.map((start, i) => {
                        return Math.round(start + (color2.color[i] - start) * t);
                    });
                    
                    return `rgb(${color})`;
                },
                getConfidenceClass(confidence) {
                    if (confidence > 95) return 'confidence-high';
                    if (confidence > 80) return 'confidence-medium';
                    return 'confidence-low';
                },
                async toggleSimulation() {
                    try {
                        this.isLoading = true;
                        if (!this.simulation.active) {
                            const response = await fetch('/start_simulation');
                            const result = await response.json();
                            if (result.success) {
                                this.simulation.active = true;
                                this.simulation.dataRows = result.data_rows || 0;
                                this.receivingData = true;
                                this.intervalId = setInterval(this.fetchData, 1000);
                                this.resetMap(9.2, -133, 10);
                                
                                // Get more detailed simulation status
                                const statusResponse = await fetch('/simulation_status');
                                const statusData = await statusResponse.json();
                                const formatMessage = statusData.data_format === "legacy" ? 
                                    " (legacy format - roll, pitch, altitude set to 0)" : 
                                    " (enhanced format with roll, pitch, altitude)";
                                
                                this.status = `Simulation started with ${result.data_rows} data points at 5x speed${formatMessage}`;
                            } else {
                                alert(`Failed to start simulation: ${result.message}`);
                            }
                        } else {
                            await fetch('/stop_simulation');
                            this.simulation.active = false;
                            this.receivingData = false;
                            clearInterval(this.intervalId);
                            this.status = 'Simulation stopped';
                        }
                    } catch (error) {
                        console.error('Simulation error:', error);
                        alert(`Simulation error: ${error.message}`);
                    } finally {
                        this.isLoading = false;
                    }
                },
                async checkLoggingStatus() {
                    try {
                        const response = await axios.get('/status');
                        if (response.data.logging_active) {
                            this.run = true;
                            this.icon = 'mdi-stop';
                            this.resetMap(9.2, -133, 10);
                            this.intervalId = setInterval(this.fetchData, 1000);
                        } else {
                            this.run = false;
                            this.icon = 'mdi-play';
                        }
                        
                        // Check simulation status
                        this.simulation.active = response.data.simulation_active || false;
                        if (this.simulation.active) {
                            this.intervalId = setInterval(this.fetchData, 1000);
                        }
                    } catch (error) {
                        console.error('Error fetching status:', error);
                        this.run = false;
                        this.icon = 'mdi-play';
                    }
                },
                resetMap(lat, lon, zoom) {
                    // Remove existing layers to prevent duplicate controls
                    if (this.map) {
                        this.map.eachLayer((layer) => {
                            if (layer instanceof L.TileLayer) {
                                this.map.removeLayer(layer);
                            }
                        });
                    
                        // Clear any existing controls including scale
                        const controls = this.map._controlCorners;
                        if (controls && controls.bottomleft) {
                            while (controls.bottomleft.firstChild) {
                                controls.bottomleft.removeChild(controls.bottomleft.firstChild);
                            }
                        }
                        
                        // Reset the map view
                        this.map.setView([lat, lon], zoom);
                        
                        // Fix mobile handling if needed
                        if (L.Browser.mobile) {
                            // Ensure touch handling is properly set
                            this.map.tap.enable();
                            // Disable dragging and re-enable after a slight delay
                            this.map.dragging.disable();
                            setTimeout(() => {
                                this.map.dragging.enable();
                            }, 500);
                        }
                        
                        // Add base layer
                        L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                            maxZoom: 21,
                            attribution: '&copy; <a href="https://www.google.com/maps">Google Maps</a>'
                        }).addTo(this.map);
                        
                        // Add fresh scale control
                        L.control.scale({imperial: false}).addTo(this.map);
                        this.scaleAdded = true;
                    }
                },
                toggleLegend() {
                    this.showLegend = !this.showLegend;
                },
                checkConnection() {
                    // Check if the WebSocket connection is alive
                    if (this.ws && this.ws.readyState !== WebSocket.OPEN) {
                        this.connected = false;
                        this.status = 'Disconnected';
                        // Try to reconnect
                        this.connectWebSocket();
                    }
                },
                onStartButtonClick() {
                    if (this.run) {
                        // Stop logging
                        fetch('/api/stop_logging')
                        .then(response => response.json())
                        .then(data => {
                            this.run = false;
                            this.icon = 'mdi-play';
                            this.status = 'Stopped';
                            document.getElementById('logoImg').classList.remove('rotate');
                        });
                    } else {
                        // Start logging
                        fetch('/api/start_logging')
                        .then(response => response.json())
                        .then(data => {
                            this.run = true;
                            this.icon = 'mdi-stop';
                            this.status = 'Recording';
                            document.getElementById('logoImg').classList.add('rotate');
                            
                            // If this is the first start, center the map appropriately
                            if (!this.firstMapCentered && this.tableItems.length > 0) {
                                const item = this.tableItems[0];
                                this.centerMapOnPosition(item.latitude, item.longitude);
                                this.firstMapCentered = true;
                            }
                            
                            // Add scale control if not already added
                            if (!this.scaleAdded) {
                                L.control.scale({imperial: false}).addTo(this.map);
                                this.scaleAdded = true;
                            }
                        });
                    }
                },
                checkLoggingStatus() {
                    // Check if logging is already in progress on page load
                    fetch('/api/status')
                    .then(response => response.json())
                    .then(data => {
                        this.run = data.logging;
                        if (this.run) {
                            this.status = 'Recording';
                            document.getElementById('logoImg').classList.add('rotate');
                        }
                    });
                },
                connectWebSocket() {
                    // Close existing connection if any
                    if (this.ws) {
                        this.ws.close();
                    }
                    
                    // Determine WebSocket URL (ws or wss depending on http/https)
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws`;
                    
                    // Create new WebSocket connection
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        this.connected = true;
                        this.status = this.run ? 'Recording' : 'Connected';
                    };
                    
                    this.ws.onclose = () => {
                        this.connected = false;
                        this.status = 'Disconnected';
                        // Try to reconnect after a delay
                        setTimeout(() => this.connectWebSocket(), 3000);
                    };
                    
                    this.ws.onerror = () => {
                        this.connected = false;
                        this.status = 'Connection Error';
                    };
                    
                    this.ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.processIncomingData(data);
                    };
                },
                processIncomingData(data) {
                    // Handle different types of messages
                    if (data.type === 'ping') {
                        // Ping message, ignore (keep-alive)
                        return;
                    }
                    
                    if (data.type === 'data') {
                        // New data point received
                        const item = data.data;
                        
                        // Add to table data
                        this.tableItems.unshift(item);
                        
                        // Limit table size to prevent memory issues
                        if (this.tableItems.length > 100) {
                            this.tableItems.pop();
                        }
                        
                        // Update vehicle position on map
                        this.updateVehicle(item.latitude, item.longitude);
                        
                        // Update heat map (only if depth is available)
                        if (item.depth !== undefined && item.depth !== null) {
                            this.updateHeatMap(item.latitude, item.longitude, item.depth);
                            this.addDepthCircle(item.latitude, item.longitude, item.depth);
                        }
                        
                        // Center map on first coordinate
                        if (!this.firstCoordinateReceived) {
                            this.centerMapOnPosition(item.latitude, item.longitude);
                            this.firstCoordinateReceived = true;
                        }
                    }
                    
                    if (data.type === 'status') {
                        // Status update
                        this.status = data.message;
                    }
                },
                
                updateVehicle(lat, lon) {
                    if (!this.map || !this.vehicleMarker) return;
                    
                    // Update vehicle marker position
                    this.vehicleMarker.setLatLng([lat, lon]);
                    this.vehicleMarker.setOpacity(1); // Make sure it's visible
                },
                
                updateHeatMap(lat, lon, depth) {
                    if (!this.map || !this.heatLayer) return;
                    
                    // Calculate intensity based on depth (normalized value)
                    const intensity = Math.max(0, Math.min(1, 1 - depth / 100));
                    
                    // Add point to heatmap
                    this.heatLayer.addLatLng([lat, lon, intensity]);
                },
                
                addDepthCircle(lat, lon, depth) {
                    if (!this.map || !this.depthLayer) return;
                    
                    // Get color for depth
                    const color = this.getColor(depth);
                    
                    // Create circle
                    const circle = L.circle([lat, lon], {
                        color: 'black',         // black outline
                        weight: 1,              // outline width
                        fillColor: color,       // fill with depth color
                        fillOpacity: 0.8,       // mostly opaque
                        radius: 5               // small fixed radius in meters
                    }).addTo(this.depthLayer);
                    
                    // Add tooltip with depth information
                    circle.bindTooltip(`Depth: ${depth.toFixed(1)} m`, {
                        permanent: false,
                        direction: 'top'
                    });
                }
            },
            mounted() {
                // Initialize map
                this.$nextTick(() => {
                    this.map = L.map('map').setView([9.2, -133], 10);
                    
                    // Add map tiles with proper attribution
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                        maxZoom: 19,
                        minZoom: 2
                    }).addTo(this.map);
                    
                    // Add scale control (metric only)
                    L.control.scale({imperial: false}).addTo(this.map);
                    
                    // Create vehicle marker if not already created
                    if (!this.vehicleMarker) {
                        const carIcon = L.icon({
                            iconUrl: '/static/img/car.png',
                            iconSize: [32, 32],
                            iconAnchor: [16, 16]
                        });
                        this.vehicleMarker = L.marker([0, 0], {icon: carIcon}).addTo(this.map);
                        this.vehicleMarker.setOpacity(0); // Hide until we have data
                    }
                    
                    // Initialize heatmap layer
                    this.heatLayer = L.heatLayer([], {
                        radius: 25,
                        blur: 15,
                        maxZoom: 10,
                    }).addTo(this.map);
                    
                    // Force a resize after initialization to ensure proper rendering
                    setTimeout(() => {
                        this.map.invalidateSize();
                    }, 100);
                    
                    // Initialize the depth visualization layer
                    this.depthLayer = L.layerGroup().addTo(this.map);
                    
                    // Get URL parameters
                    const urlParams = new URLSearchParams(window.location.search);
                    this.isWidget = urlParams.get('widget') === 'true';
                    
                    // If in widget mode, auto-start data logging
                    if (this.isWidget) {
                        this.onStartButtonClick();
                    }
                    
                    // Check WebSocket connection status periodically
                    this.connectionCheckInterval = setInterval(this.checkConnection, 5000);
                    
                    // Check if logging is already active
                    this.checkLoggingStatus();
                    
                    // Initialize WebSocket connection
                    this.connectWebSocket();
                });
            }
        })
    </script>
</body>
</html>
